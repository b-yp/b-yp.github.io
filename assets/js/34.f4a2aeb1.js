(window.webpackJsonp=window.webpackJsonp||[]).push([[34],{1199:function(e,t,a){"use strict";a.r(t);var r=a(24),v=Object(r.a)({},(function(){var e=this,t=e.$createElement,a=e._self._c||t;return a("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[a("blockquote",[a("p",[e._v("本文由 "),a("a",{attrs:{href:"http://ksria.com/simpread/",target:"_blank",rel:"noopener noreferrer"}},[e._v("简悦 SimpRead"),a("OutboundLink")],1),e._v(" 转码， 原文地址 https://zhuanlan.zhihu.com/p/63962882 "),a("a",{attrs:{href:"https://github.com/woai3c/Front-end-basic-knowledge",target:"_blank",rel:"noopener noreferrer"}},[e._v("项目地址​github.com"),a("OutboundLink")],1)])]),e._v(" "),a("h2",{attrs:{id:"html-问题"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#html-问题"}},[e._v("#")]),e._v(" HTML 问题")]),e._v(" "),a("blockquote",[a("p",[e._v("项目地址：https://github.com/woai3c/Front-end-basic-knowledge")])]),e._v(" "),a("h2",{attrs:{id:"html5-语义化"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#html5-语义化"}},[e._v("#")]),e._v(" HTML5 语义化")]),e._v(" "),a("p",[e._v("什么是语义化？就是用合理、正确的标签来展示内容，比如 h1~h6 定义标题。")]),e._v(" "),a("h3",{attrs:{id:"好处"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#好处"}},[e._v("#")]),e._v(" 好处")]),e._v(" "),a("ul",[a("li",[e._v("易于用户阅读，样式丢失的时候能让页面呈现清晰的结构。")]),e._v(" "),a("li",[e._v("有利于 SEO，搜索引擎根据标签来确定上下文和各个关键字的权重。")]),e._v(" "),a("li",[e._v("方便其他设备解析，如盲人阅读器根据语义渲染网页")]),e._v(" "),a("li",[e._v("有利于开发和维护，语义化更具可读性，代码更好维护，与 CSS3 关系更和谐。")])]),e._v(" "),a("p",[a("a",{attrs:{href:"http://www.daqianduan.com/6549.html",target:"_blank",rel:"noopener noreferrer"}},[e._v("http://www.daqianduan.com/6549.html"),a("OutboundLink")],1)]),e._v(" "),a("h2",{attrs:{id:"为什么最好把-css-的-link-标签放在-head-head-之间-为什么最好把-js-的-script-标签恰好放在-body-之前-有例外情况吗"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#为什么最好把-css-的-link-标签放在-head-head-之间-为什么最好把-js-的-script-标签恰好放在-body-之前-有例外情况吗"}},[e._v("#")]),e._v(" 为什么最好把 CSS 的"),a("code",[e._v("<link>")]),e._v("标签放在"),a("code",[e._v("<head></head>")]),e._v("之间？为什么最好把 JS 的"),a("code",[e._v("<script>")]),e._v("标签恰好放在"),a("code",[e._v("</body>")]),e._v("之前，有例外情况吗？")]),e._v(" "),a("p",[a("strong",[e._v("把"),a("code",[e._v("<link>")]),e._v("放在"),a("code",[e._v("<head>")]),e._v("中")])]),e._v(" "),a("p",[e._v("把"),a("code",[e._v("<link>")]),e._v("标签放在"),a("code",[e._v("<head></head>")]),e._v("之间是规范要求的内容。此外，这种做法可以让页面逐步呈现，提高了用户体验。将样式表放在文档底部附近，会使许多浏览器（包括 Internet Explorer）不能逐步呈现页面。一些浏览器会阻止渲染，以避免在页面样式发生变化时，重新绘制页面中的元素。这种做法可以防止呈现给用户空白的页面或没有样式的内容。")]),e._v(" "),a("p",[a("strong",[e._v("把"),a("code",[e._v("<script>")]),e._v("标签恰好放在"),a("code",[e._v("</body>")]),e._v("之前")])]),e._v(" "),a("p",[e._v("脚本在下载和执行期间会阻止 HTML 解析。把"),a("code",[e._v("<script>")]),e._v("标签放在底部，保证 HTML 首先完成解析，将页面尽早呈现给用户。")]),e._v(" "),a("p",[e._v("例外情况是当你的脚本里包含"),a("code",[e._v("document.write()")]),e._v("时。但是现在，"),a("code",[e._v("document.write()")]),e._v("不推荐使用。同时，将"),a("code",[e._v("<script>")]),e._v("标签放在底部，意味着浏览器不能开始下载脚本，直到整个文档（document）被解析。也许，对此比较好的做法是，"),a("code",[e._v("<script>")]),e._v("使用"),a("code",[e._v("defer")]),e._v("属性，放在"),a("code",[e._v("<head>")]),e._v("中。")]),e._v(" "),a("h2",{attrs:{id:"什么是渐进式渲染-progressive-rendering"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#什么是渐进式渲染-progressive-rendering"}},[e._v("#")]),e._v(" 什么是渐进式渲染（progressive rendering）？")]),e._v(" "),a("p",[e._v("渐进式渲染是用于提高网页性能（尤其是提高用户感知的加载速度），以尽快呈现页面的技术。")]),e._v(" "),a("p",[e._v("在以前互联网带宽较小的时期，这种技术更为普遍。如今，移动终端的盛行，而移动网络往往不稳定，渐进式渲染在现代前端开发中仍然有用武之地。")]),e._v(" "),a("p",[e._v("一些举例：")]),e._v(" "),a("ul",[a("li",[e._v("图片懒加载——页面上的图片不会一次性全部加载。当用户滚动页面到图片部分时，JavaScript 将加载并显示图像。")]),e._v(" "),a("li",[e._v("确定显示内容的优先级（分层次渲染）——为了尽快将页面呈现给用户，页面只包含基本的最少量的 CSS、脚本和内容，然后可以使用延迟加载脚本或监听"),a("code",[e._v("DOMContentLoaded")]),e._v("/"),a("code",[e._v("load")]),e._v("事件加载其他资源和内容。")]),e._v(" "),a("li",[e._v("异步加载 HTML 片段——当页面通过后台渲染时，把 HTML 拆分，通过异步请求，分块发送给浏览器。更多相关细节可以在"),a("a",{attrs:{href:"http://www.ebaytechblog.com/2014/12/08/async-fragments-rediscovering-progressive-html-rendering-with-marko/",target:"_blank",rel:"noopener noreferrer"}},[e._v("这里"),a("OutboundLink")],1),e._v("找到。")])]),e._v(" "),a("h2",{attrs:{id:"viewport"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#viewport"}},[e._v("#")]),e._v(" viewport")]),e._v(" "),a("p",[e._v("Viewport ：字面意思为视图窗口，在移动 web 开发中使用。表示将设备浏览器宽度虚拟成一个特定的值（或计算得出），这样利于移动 web 站点跨设备显示效果基本一致。移动版的 Safari 浏览器最新引进了 viewport 这个 meta tag，让网页开发者来控制 viewport 的大小和缩放，其他手机浏览器也基本支持。")]),e._v(" "),a("p",[e._v("在移动端浏览器当中，存在着两种视口，一种是可见视口（也就是我们说的设备大小），另一种是视窗视口（网页的宽度是多少）。 举个例子：如果我们的屏幕是 320 像素 * 480 像素的大小（iPhone4），假设在浏览器中，320 像素的屏幕宽度能够展示 980 像素宽度的内容。那么 320 像素的宽度就是可见视口的宽度，而能够显示的 980 像素的宽度就是视窗视口的宽度。")]),e._v(" "),a("p",[e._v("为了显示更多的内容，大多数的浏览器会把自己的视窗视口扩大，简易的理解，就是让原本 320 像素的屏幕宽度能够容下 980 像素甚至更宽的内容（将网页等比例缩小）。")]),e._v(" "),a("h3",{attrs:{id:"viewport-属性值"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#viewport-属性值"}},[e._v("#")]),e._v(" Viewport 属性值")]),e._v(" "),a("ul",[a("li",[e._v('width 设置 layout viewport 的宽度，为一个正整数，或字符串 "width-device"')]),e._v(" "),a("li",[e._v("initial-scale 设置页面的初始缩放值，为一个数字，可以带小数")]),e._v(" "),a("li",[e._v("minimum-scale 允许用户的最小缩放值，为一个数字，可以带小数")]),e._v(" "),a("li",[e._v("maximum-scale 允许用户的最大缩放值，为一个数字，可以带小数")]),e._v(" "),a("li",[e._v("height 设置 layout viewport 的高度，这个属性对我们并不重要，很少使用")]),e._v(" "),a("li",[e._v('user-scalable 是否允许用户进行缩放，值为 "no" 或 "yes", no 代表不允许，yes 代表允许这些属性可以同时使用，也可以单独使用或混合使用，多个属性同时使用时用逗号隔开就行了。')])]),e._v(" "),a("h2",{attrs:{id:"reflow-和-repaint"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#reflow-和-repaint"}},[e._v("#")]),e._v(" Reflow 和 Repaint")]),e._v(" "),a("h3",{attrs:{id:"reflow"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#reflow"}},[e._v("#")]),e._v(" Reflow")]),e._v(" "),a("p",[e._v("当涉及到 DOM 节点的布局属性发生变化时，就会重新计算该属性，浏览器会重新描绘相应的元素，此过程叫 Reflow（回流或重排）。")]),e._v(" "),a("h3",{attrs:{id:"repaint"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#repaint"}},[e._v("#")]),e._v(" Repaint")]),e._v(" "),a("p",[e._v("当影响 DOM 元素可见性的属性发生变化 (如 color) 时, 浏览器会重新描绘相应的元素, 此过程称为 Repaint（重绘）。因此重排必然会引起重绘。")]),e._v(" "),a("h3",{attrs:{id:"引起-repaint-和-reflow-的一些操作"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#引起-repaint-和-reflow-的一些操作"}},[e._v("#")]),e._v(" 引起 Repaint 和 Reflow 的一些操作")]),e._v(" "),a("ul",[a("li",[e._v("调整窗口大小")]),e._v(" "),a("li",[e._v("字体大小")]),e._v(" "),a("li",[e._v("样式表变动")]),e._v(" "),a("li",[e._v("元素内容变化，尤其是输入控件")]),e._v(" "),a("li",[e._v("CSS 伪类激活，在用户交互过程中发生")]),e._v(" "),a("li",[e._v("DOM 操作，DOM 元素增删、修改")]),e._v(" "),a("li",[e._v("width, clientWidth, scrollTop 等布局宽高的计算")])]),e._v(" "),a("h3",{attrs:{id:"repaint-和-reflow-是不可避免的-只能说对性能的影响减到最小-给出下面几条建议"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#repaint-和-reflow-是不可避免的-只能说对性能的影响减到最小-给出下面几条建议"}},[e._v("#")]),e._v(" Repaint 和 Reflow 是不可避免的，只能说对性能的影响减到最小，给出下面几条建议：")]),e._v(" "),a("ul",[a("li",[e._v("避免逐条更改样式。建议集中修改样式，例如操作 className。")]),e._v(" "),a("li",[e._v("避免频繁操作 DOM。创建一个 documentFragment 或 div，在它上面应用所有 DOM 操作，最后添加到文档里。设置 display:none 的元素上操作，最后显示出来。")]),e._v(" "),a("li",[e._v("避免频繁读取元素几何属性（例如 scrollTop）。绝对定位具有复杂动画的元素。")]),e._v(" "),a("li",[e._v("绝对定位使它脱离文档流，避免引起父元素及后续元素大量的回流")])]),e._v(" "),a("p",[a("a",{attrs:{href:"https://harttle.land/2015/08/11/reflow-repaint.html",target:"_blank",rel:"noopener noreferrer"}},[e._v("https://harttle.land/2015/08/11/reflow-repaint.html"),a("OutboundLink")],1),a("br"),e._v(" "),a("a",{attrs:{href:"http://www.blueidea.com/tech/web/2011/8365.asp",target:"_blank",rel:"noopener noreferrer"}},[e._v("http://www.blueidea.com/tech/web/2011/8365.asp"),a("OutboundLink")],1)]),e._v(" "),a("h2",{attrs:{id:"img-中的-alt-和元素的-title-属性作用"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#img-中的-alt-和元素的-title-属性作用"}},[e._v("#")]),e._v(" img 中的 alt 和元素的 title 属性作用")]),e._v(" "),a("ul",[a("li",[e._v("img 的 alt 属性"),a("br"),e._v("\n如果无法显示图像，浏览器将显示 alt 指定的内容")]),e._v(" "),a("li",[e._v("元素 title 属性"),a("br"),e._v("\n在鼠标移到元素上时显示 title 的内容")])]),e._v(" "),a("h2",{attrs:{id:"href-和-src-区别"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#href-和-src-区别"}},[e._v("#")]),e._v(" href 和 src 区别")]),e._v(" "),a("ul",[a("li",[e._v("href"),a("br"),e._v("\nhref 标识超文本引用，用在 link 和 a 等元素上，href 是引用和页面关联，是在当前元素和引用资源之间建立联系"),a("br"),e._v("\n若在文档中添加 href ，浏览器会识别该文档为 CSS 文件，就会并行下载资源并且不会停止对当前文档的处理。这也是为什么建议使用 link 方式加载 CSS，而不是使用 @import 方式。")]),e._v(" "),a("li",[e._v("src"),a("br"),e._v("\nsrc 表示引用资源，替换当前元素，用在 img，script，iframe 上，src 是页面内容不可缺少的一部分。"),a("br"),e._v("\n当浏览器解析到 src ，会暂停其他资源的下载和处理（图片不会暂停其他资源下载），直到将该资源加载、编译、执行完毕，类似于将所指向资源应用到当前内容。这也是为什么建议把 js 脚本放在底部而不是头部的原因。")])]),e._v(" "),a("p",[a("a",{attrs:{href:"https://blog.csdn.net/lhjuejiang/article/details/80795081",target:"_blank",rel:"noopener noreferrer"}},[e._v("https://blog.csdn.net/lhjuejiang/article/details/80795081"),a("OutboundLink")],1)]),e._v(" "),a("h2",{attrs:{id:"浏览器的渲染过程"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#浏览器的渲染过程"}},[e._v("#")]),e._v(" 浏览器的渲染过程")]),e._v(" "),a("ol",[a("li",[e._v("解析 HTML 生成 DOM 树。")]),e._v(" "),a("li",[e._v("解析 CSS 生成 CSSOM 规则树。")]),e._v(" "),a("li",[e._v("将 DOM 树与 CSSOM 规则树合并在一起生成渲染树。")]),e._v(" "),a("li",[e._v("遍历渲染树开始布局，计算每个节点的位置大小信息。")]),e._v(" "),a("li",[e._v("将渲染树每个节点绘制到屏幕。")])]),e._v(" "),a("p",[a("a",{attrs:{href:"https://baijiahao.baidu.com/s?id=1593097105869520145&wfr=spider&for=pc",target:"_blank",rel:"noopener noreferrer"}},[e._v("https://baijiahao.baidu.com/s?id=1593097105869520145&wfr=spider&for=pc"),a("OutboundLink")],1)]),e._v(" "),a("h2",{attrs:{id:"为何会出现浏览器兼容问题"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#为何会出现浏览器兼容问题"}},[e._v("#")]),e._v(" 为何会出现浏览器兼容问题")]),e._v(" "),a("ul",[a("li",[e._v("同一产品，版本越老 bug 越多")]),e._v(" "),a("li",[e._v("同一产品，版本越新，功能越多")]),e._v(" "),a("li",[e._v("不同产品，不同标准，不同实现方式")])]),e._v(" "),a("h3",{attrs:{id:"处理兼容问题的思路"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#处理兼容问题的思路"}},[e._v("#")]),e._v(" 处理兼容问题的思路")]),e._v(" "),a("ol",[a("li",[a("p",[e._v("要不要做")])]),e._v(" "),a("li",[a("p",[e._v("产品的角度（产品的受众、受众的浏览器比例、效果优先还是基本功能优先）")])]),e._v(" "),a("li",[a("p",[e._v("成本的角度 (有无必要做某件事)")])]),e._v(" "),a("li",[a("p",[e._v("做到什么程度 * 让哪些浏览器支持哪些效果")])])]),e._v(" "),a("p",[e._v("3.. 如何做 "),a("em",[e._v("根据兼容需求选择技术框架 / 库 (jquery)")]),e._v(" 根据兼容需求选择兼容工具 (html5shiv.js、respond.js、css reset、normalize.css、Modernizr) * 条件注释、CSS Hack、js 能力检测做一些修补")]),e._v(" "),a("ul",[a("li",[e._v("渐进增强 (progressive enhancement): 针对低版本浏览器进行构建页面，保证最基本的功能，然后再针对高级浏览器进行效果、交互等改进和追加功能达到更好的用户体验")]),e._v(" "),a("li",[e._v("优雅降级 (graceful degradation): 一开始就构建完整的功能，然后再针对低版本浏览器进行兼容。")])]),e._v(" "),a("p",[a("a",{attrs:{href:"https://github.com/jirengu/frontend-interview/issues/35",target:"_blank",rel:"noopener noreferrer"}},[e._v("https://github.com/jirengu/frontend-interview/issues/35"),a("OutboundLink")],1)]),e._v(" "),a("h2",{attrs:{id:"doctype-有什么用"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#doctype-有什么用"}},[e._v("#")]),e._v(" doctype 有什么用")]),e._v(" "),a("p",[e._v("doctype 是一种标准通用标记语言的文档类型声明，目的是告诉标准通用标记语言解析器要使用什么样的文档类型定义（DTD）来解析文档。")]),e._v(" "),a("p",[e._v("声明是用来指示 web 浏览器关于页面使用哪个 HTML 版本进行编写的指令。 声明必须是 HTML 文档的第一行，位于 html 标签之前。")]),e._v(" "),a("p",[e._v("浏览器本身分为两种模式，一种是标准模式，一种是怪异模式，浏览器通过 doctype 来区分这两种模式，doctype 在 html 中的作用就是触发浏览器的标准模式，如果 html 中省略了 doctype，浏览器就会进入到 Quirks 模式的怪异状态，在这种模式下，有些样式会和标准模式存在差异，而 html 标准和 dom 标准值规定了标准模式下的行为，没有对怪异模式做出规定，因此不同浏览器在怪异模式下的处理也是不同的，所以一定要在 html 开头使用 doctype。")]),e._v(" "),a("h2",{attrs:{id:"行内元素和块级元素有哪些"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#行内元素和块级元素有哪些"}},[e._v("#")]),e._v(" 行内元素和块级元素有哪些")]),e._v(" "),a("h3",{attrs:{id:"行内元素"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#行内元素"}},[e._v("#")]),e._v(" 行内元素")]),e._v(" "),a("p",[e._v("一个行内元素只占据它对应标签的边框所包含的空间"),a("br"),e._v("\n一般情况下，行内元素只能包含数据和其他行内元素")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("b, big, i, small, tt\nabbr, acronym, cite, code, dfn, em, kbd, strong, samp, var\na, bdo, br, img, map, object, q, script, span, sub, sup\nbutton, input, label, select, textarea\n")])])]),a("h3",{attrs:{id:"块级元素"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#块级元素"}},[e._v("#")]),e._v(" 块级元素")]),e._v(" "),a("p",[e._v("占据一整行，高度、行高、内边距和外边距都可以改变，可以容纳块级标签和其他行内标签")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("header,form,ul,ol,table,article,div,hr,aside,figure,canvas,video,audio,footer\n")])])]),a("h2",{attrs:{id:"iframe-框架有那些优缺点"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#iframe-框架有那些优缺点"}},[e._v("#")]),e._v(" iframe 框架有那些优缺点")]),e._v(" "),a("h3",{attrs:{id:"优点"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#优点"}},[e._v("#")]),e._v(" 优点：")]),e._v(" "),a("ul",[a("li",[e._v("iframe 能够原封不动的把嵌入的网页展现出来。")]),e._v(" "),a("li",[e._v("如果有多个网页引用 iframe，那么你只需要修改 iframe 的内容，就可以实现调用的每一个页面内容的更改，方便快捷。")]),e._v(" "),a("li",[e._v("网页如果为了统一风格，头部和版本都是一样的，就可以写成一个页面，用 iframe 来嵌套，可以增加代码的可重用。")]),e._v(" "),a("li",[e._v("如果遇到加载缓慢的第三方内容如图标和广告，这些问题可以由 iframe 来解决。")])]),e._v(" "),a("h3",{attrs:{id:"缺点"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#缺点"}},[e._v("#")]),e._v(" 缺点：")]),e._v(" "),a("ul",[a("li",[e._v("搜索引擎的爬虫程序无法解读这种页面")]),e._v(" "),a("li",[e._v("框架结构中出现各种滚动条")]),e._v(" "),a("li",[e._v("使用框架结构时，保证设置正确的导航链接。")]),e._v(" "),a("li",[e._v("iframe 页面会增加服务器的 http 请求")])]),e._v(" "),a("h2",{attrs:{id:"label-标签有什么作用"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#label-标签有什么作用"}},[e._v("#")]),e._v(" label 标签有什么作用")]),e._v(" "),a("p",[a("code",[e._v("label")]),e._v(" 标签通常是写在表单内，它关联一个控件，使用 "),a("code",[e._v("label")]),e._v(" 可以实现点击文字选取对应的控件。")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v('<input type="checkbox">\n<label for="test" >test</label>\n')])])]),a("h2",{attrs:{id:"html5-的-form-如何关闭自动完成功能"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#html5-的-form-如何关闭自动完成功能"}},[e._v("#")]),e._v(" HTML5 的 form 如何关闭自动完成功能")]),e._v(" "),a("p",[e._v("将不想要自动完成的 "),a("code",[e._v("form")]),e._v(" 或 "),a("code",[e._v("input")]),e._v(" 设置为 "),a("code",[e._v("autocomplete=off")])]),e._v(" "),a("p",[a("a",{attrs:{href:"https://developer.mozilla.org/zh-CN/docs/Web/Security/Securing_your_site/Turning_off_form_autocompletion",target:"_blank",rel:"noopener noreferrer"}},[e._v("MDN"),a("OutboundLink")],1)]),e._v(" "),a("h2",{attrs:{id:"dom-和-bom-有什么区别"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#dom-和-bom-有什么区别"}},[e._v("#")]),e._v(" DOM 和 BOM 有什么区别")]),e._v(" "),a("ul",[a("li",[e._v("DOM")])]),e._v(" "),a("p",[e._v("Document Object Model，文档对象模型")]),e._v(" "),a("p",[e._v("DOM 是为了操作文档出现的 API，document 是其的一个对象")]),e._v(" "),a("p",[e._v("DOM 和文档有关，这里的文档指的是网页，也就是 html 文档。DOM 和浏览器无关，他关注的是网页本身的内容。")]),e._v(" "),a("ul",[a("li",[e._v("BOM")])]),e._v(" "),a("p",[e._v("Browser Object Model，浏览器对象模型")]),e._v(" "),a("p",[e._v("BOM 是为了操作浏览器出现的 API，window 是其的一个对象")]),e._v(" "),a("p",[e._v("window 对象既为 javascript 访问浏览器提供 API，同时在 ECMAScript 中充当 Global 对象")]),e._v(" "),a("h2",{attrs:{id:"css-问题"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#css-问题"}},[e._v("#")]),e._v(" CSS 问题")]),e._v(" "),a("h3",{attrs:{id:"css-选择器的优先级是如何计算的"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#css-选择器的优先级是如何计算的"}},[e._v("#")]),e._v(" CSS 选择器的优先级是如何计算的？")]),e._v(" "),a("p",[e._v("浏览器通过优先级规则，判断元素展示哪些样式。优先级通过 4 个维度指标确定，我们假定以"),a("code",[e._v("a、b、c、d")]),e._v("命名，分别代表以下含义：")]),e._v(" "),a("ol",[a("li",[a("code",[e._v("a")]),e._v("表示是否使用内联样式（inline style）。如果使用，"),a("code",[e._v("a")]),e._v("为 1，否则为 0。")]),e._v(" "),a("li",[a("code",[e._v("b")]),e._v("表示 ID 选择器的数量。")]),e._v(" "),a("li",[a("code",[e._v("c")]),e._v("表示类选择器、属性选择器和伪类选择器数量之和。")]),e._v(" "),a("li",[a("code",[e._v("d")]),e._v("表示标签（类型）选择器和伪元素选择器之和。")])]),e._v(" "),a("p",[e._v("优先级的结果并非通过以上四个值生成一个得分，而是每个值分开比较。"),a("code",[e._v("a、b、c、d")]),e._v("权重从左到右，依次减小。判断优先级时，从左到右，一一比较，直到比较出最大值，即可停止。所以，如果"),a("code",[e._v("b")]),e._v("的值不同，那么"),a("code",[e._v("c")]),e._v("和"),a("code",[e._v("d")]),e._v("不管多大，都不会对结果产生影响。比如"),a("code",[e._v("0，1，0，0")]),e._v("的优先级高于"),a("code",[e._v("0，0，10，10")]),e._v("。")]),e._v(" "),a("p",[e._v("当出现优先级相等的情况时，最晚出现的样式规则会被采纳。如果你在样式表里写了相同的规则（无论是在该文件内部还是其它样式文件中），那么最后出现的（在文件底部的）样式优先级更高，因此会被采纳。")]),e._v(" "),a("p",[e._v("在写样式时，我会使用较低的优先级，这样这些样式可以轻易地覆盖掉。尤其对写 UI 组件的时候更为重要，这样使用者就不需要通过非常复杂的优先级规则或使用"),a("code",[e._v("!important")]),e._v("的方式，去覆盖组件的样式了。")]),e._v(" "),a("h3",{attrs:{id:"参考"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#参考"}},[e._v("#")]),e._v(" 参考")]),e._v(" "),a("ul",[a("li",[a("a",{attrs:{href:"https://www.smashingmagazine.com/2007/07/css-specificity-things-you-should-know/",target:"_blank",rel:"noopener noreferrer"}},[e._v("https://www.smashingmagazine.com/2007/07/css-specificity-things-you-should-know/"),a("OutboundLink")],1)]),e._v(" "),a("li",[a("a",{attrs:{href:"https://www.sitepoint.com/web-foundations/specificity/",target:"_blank",rel:"noopener noreferrer"}},[e._v("https://www.sitepoint.com/web-foundations/specificity/"),a("OutboundLink")],1)])]),e._v(" "),a("h3",{attrs:{id:"重置-resetting-css-和-标准化-normalizing-css-的区别是什么-你会选择哪种方式-为什么"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#重置-resetting-css-和-标准化-normalizing-css-的区别是什么-你会选择哪种方式-为什么"}},[e._v("#")]),e._v(" 重置（resetting）CSS 和 标准化（normalizing）CSS 的区别是什么？你会选择哪种方式，为什么？")]),e._v(" "),a("ul",[a("li",[a("strong",[e._v("重置（Resetting）")]),e._v("： 重置意味着除去所有的浏览器默认样式。对于页面所有的元素，像"),a("code",[e._v("margin")]),e._v("、"),a("code",[e._v("padding")]),e._v("、"),a("code",[e._v("font-size")]),e._v("这些样式全部置成一样。你将必须重新定义各种元素的样式。")]),e._v(" "),a("li",[a("strong",[e._v("标准化（Normalizing）")]),e._v("： 标准化没有去掉所有的默认样式，而是保留了有用的一部分，同时还纠正了一些常见错误。")])]),e._v(" "),a("p",[e._v("当需要实现非常个性化的网页设计时，我会选择重置的方式，因为我要写很多自定义的样式以满足设计需求，这时候就不再需要标准化的默认样式了。")]),e._v(" "),a("h3",{attrs:{id:"参考-2"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#参考-2"}},[e._v("#")]),e._v(" 参考")]),e._v(" "),a("ul",[a("li",[a("a",{attrs:{href:"https://stackoverflow.com/questions/6887336/what-is-the-difference-between-normalize-css-and-reset-css",target:"_blank",rel:"noopener noreferrer"}},[e._v("https://stackoverflow.com/questions/6887336/what-is-the-difference-between-normalize-css-and-reset-css"),a("OutboundLink")],1)])]),e._v(" "),a("h3",{attrs:{id:"请阐述float定位的工作原理。"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#请阐述float定位的工作原理。"}},[e._v("#")]),e._v(" 请阐述"),a("code",[e._v("Float")]),e._v("定位的工作原理。")]),e._v(" "),a("p",[e._v("浮动（float）是 CSS 定位属性。浮动元素从网页的正常流动中移出，但是保持了部分的流动性，会影响其他元素的定位（比如文字会围绕着浮动元素）。这一点与绝对定位不同，绝对定位的元素完全从文档流中脱离。")]),e._v(" "),a("p",[e._v("CSS 的"),a("code",[e._v("clear")]),e._v("属性通过使用"),a("code",[e._v("left")]),e._v("、"),a("code",[e._v("right")]),e._v("、"),a("code",[e._v("both")]),e._v("，让该元素向下移动（清除浮动）到浮动元素下面。")]),e._v(" "),a("p",[e._v("如果父元素只包含浮动元素，那么该父元素的高度将塌缩为 0。我们可以通过清除（clear）从浮动元素后到父元素关闭前之间的浮动来修复这个问题。")]),e._v(" "),a("p",[e._v("有一种 hack 的方法，是自定义一个"),a("code",[e._v(".clearfix")]),e._v("类，利用伪元素选择器"),a("code",[e._v("::after")]),e._v("清除浮动。"),a("a",{attrs:{href:"https://css-tricks.com/all-about-floats/#article-header-id-4",target:"_blank",rel:"noopener noreferrer"}},[e._v("另外还有一些方法"),a("OutboundLink")],1),e._v("，比如添加空的"),a("code",[e._v("<div></div>")]),e._v("和设置浮动元素父元素的"),a("code",[e._v("overflow")]),e._v("属性。与这些方法不同的是，"),a("code",[e._v("clearfix")]),e._v("方法，只需要给父元素添加一个类，定义如下：")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v(".clearfix::after {\n  content: '';\n  display: block;\n  clear: both;\n}\n")])])]),a("p",[e._v("值得一提的是，把父元素属性设置为"),a("code",[e._v("overflow: auto")]),e._v("或"),a("code",[e._v("overflow: hidden")]),e._v("，会使其内部的子元素形成块格式化上下文（Block Formatting Context），并且父元素会扩张自己，使其能够包围它的子元素。")]),e._v(" "),a("h3",{attrs:{id:"参考-3"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#参考-3"}},[e._v("#")]),e._v(" 参考")]),e._v(" "),a("ul",[a("li",[a("a",{attrs:{href:"https://css-tricks.com/all-about-floats/",target:"_blank",rel:"noopener noreferrer"}},[e._v("https://css-tricks.com/all-about-floats/"),a("OutboundLink")],1)])]),e._v(" "),a("h3",{attrs:{id:"请阐述z-index属性-并说明如何形成层叠上下文-stacking-context-。"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#请阐述z-index属性-并说明如何形成层叠上下文-stacking-context-。"}},[e._v("#")]),e._v(" 请阐述"),a("code",[e._v("z-index")]),e._v("属性，并说明如何形成层叠上下文（stacking context）。")]),e._v(" "),a("p",[e._v("CSS 中的"),a("code",[e._v("z-index")]),e._v("属性控制重叠元素的垂直叠加顺序。"),a("code",[e._v("z-index")]),e._v("只能影响"),a("code",[e._v("position")]),e._v("值不是"),a("code",[e._v("static")]),e._v("的元素。")]),e._v(" "),a("p",[e._v("没有定义"),a("code",[e._v("z-index")]),e._v("的值时，元素按照它们出现在 DOM 中的顺序堆叠（层级越低，出现位置越靠上）。非静态定位的元素（及其子元素）将始终覆盖静态定位（static）的元素，而不管 HTML 层次结构如何。")]),e._v(" "),a("p",[e._v("层叠上下文是包含一组图层的元素。 在一组层叠上下文中，其子元素的"),a("code",[e._v("z-index")]),e._v("值是相对于该父元素而不是 document root 设置的。每个层叠上下文完全独立于它的兄弟元素。如果元素 B 位于元素 A 之上，则即使元素 A 的子元素 C 具有比元素 B 更高的"),a("code",[e._v("z-index")]),e._v("值，元素 C 也永远不会在元素 B 之上.")]),e._v(" "),a("p",[e._v("每个层叠上下文是自包含的：当元素的内容发生层叠后，整个该元素将会在父层叠上下文中按顺序进行层叠。少数 CSS 属性会触发一个新的层叠上下文，例如"),a("code",[e._v("opacity")]),e._v("小于 1，"),a("code",[e._v("filter")]),e._v("不是"),a("code",[e._v("none")]),e._v("，"),a("code",[e._v("transform")]),e._v("不是"),a("code",[e._v("none")]),e._v("。")]),e._v(" "),a("h3",{attrs:{id:"参考-4"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#参考-4"}},[e._v("#")]),e._v(" 参考")]),e._v(" "),a("ul",[a("li",[a("a",{attrs:{href:"https://css-tricks.com/almanac/properties/z/z-index/",target:"_blank",rel:"noopener noreferrer"}},[e._v("https://css-tricks.com/almanac/properties/z/z-index/"),a("OutboundLink")],1)]),e._v(" "),a("li",[a("a",{attrs:{href:"https://philipwalton.com/articles/what-no-one-told-you-about-z-index/",target:"_blank",rel:"noopener noreferrer"}},[e._v("https://philipwalton.com/articles/what-no-one-told-you-about-z-index/"),a("OutboundLink")],1)]),e._v(" "),a("li",[a("a",{attrs:{href:"https://developer.mozilla.org/en-US/docs/Web/CSS/CSS_Positioning/Understanding_z_index/The_stacking_context",target:"_blank",rel:"noopener noreferrer"}},[e._v("https://developer.mozilla.org/en-US/docs/Web/CSS/CSS_Positioning/Understanding_z_index/The_stacking_context"),a("OutboundLink")],1)])]),e._v(" "),a("h3",{attrs:{id:"请阐述块格式化上下文-block-formatting-context-及其工作原理。"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#请阐述块格式化上下文-block-formatting-context-及其工作原理。"}},[e._v("#")]),e._v(" 请阐述块格式化上下文（Block Formatting Context）及其工作原理。")]),e._v(" "),a("p",[e._v("块格式上下文（BFC）是 Web 页面的可视化 CSS 渲染的部分，是块级盒布局发生的区域，也是浮动元素与其他元素交互的区域。")]),e._v(" "),a("p",[e._v("一个 HTML 盒（Box）满足以下任意一条，会创建块格式化上下文：")]),e._v(" "),a("ul",[a("li",[a("code",[e._v("float")]),e._v("的值不是"),a("code",[e._v("none")]),e._v(".")]),e._v(" "),a("li",[a("code",[e._v("position")]),e._v("的值不是"),a("code",[e._v("static")]),e._v("或"),a("code",[e._v("relative")]),e._v(".")]),e._v(" "),a("li",[a("code",[e._v("display")]),e._v("的值是"),a("code",[e._v("table-cell")]),e._v("、"),a("code",[e._v("table-caption")]),e._v("、"),a("code",[e._v("inline-block")]),e._v("、"),a("code",[e._v("flex")]),e._v("、或"),a("code",[e._v("inline-flex")]),e._v("。")]),e._v(" "),a("li",[a("code",[e._v("overflow")]),e._v("的值不是"),a("code",[e._v("visible")]),e._v("。")])]),e._v(" "),a("p",[e._v("在 BFC 中，每个盒的左外边缘都与其包含的块的左边缘相接。")]),e._v(" "),a("p",[e._v("两个相邻的块级盒在垂直方向上的边距会发生合并（collapse）。更多内容请参考"),a("a",{attrs:{href:"https://www.sitepoint.com/web-foundations/collapsing-margins/",target:"_blank",rel:"noopener noreferrer"}},[e._v("边距合并（margin collapsing）"),a("OutboundLink")],1),e._v("。")]),e._v(" "),a("h3",{attrs:{id:"参考-5"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#参考-5"}},[e._v("#")]),e._v(" 参考")]),e._v(" "),a("ul",[a("li",[a("a",{attrs:{href:"https://developer.mozilla.org/en-US/docs/Web/Guide/CSS/Block_formatting_context",target:"_blank",rel:"noopener noreferrer"}},[e._v("https://developer.mozilla.org/en-US/docs/Web/Guide/CSS/Block_formatting_context"),a("OutboundLink")],1)]),e._v(" "),a("li",[a("a",{attrs:{href:"https://www.sitepoint.com/understanding-block-formatting-contexts-in-css/",target:"_blank",rel:"noopener noreferrer"}},[e._v("https://www.sitepoint.com/understanding-block-formatting-contexts-in-css/"),a("OutboundLink")],1)])]),e._v(" "),a("h3",{attrs:{id:"有哪些清除浮动的技术-都适用哪些情况"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#有哪些清除浮动的技术-都适用哪些情况"}},[e._v("#")]),e._v(" 有哪些清除浮动的技术，都适用哪些情况？")]),e._v(" "),a("ul",[a("li",[e._v("空"),a("code",[e._v("div")]),e._v("方法："),a("code",[e._v("<div></div>")]),e._v("。")]),e._v(" "),a("li",[e._v("Clearfix 方法：上文使用"),a("code",[e._v(".clearfix")]),e._v("类已经提到。")]),e._v(" "),a("li",[a("code",[e._v("overflow: auto")]),e._v("或"),a("code",[e._v("overflow: hidden")]),e._v("方法：上文已经提到。")])]),e._v(" "),a("p",[e._v("在大型项目中，我会使用 Clearfix 方法，在需要的地方使用"),a("code",[e._v(".clearfix")]),e._v("。设置"),a("code",[e._v("overflow: hidden")]),e._v("的方法可能使其子元素显示不完整，当子元素的高度大于父元素时。")]),e._v(" "),a("h3",{attrs:{id:"请解释什么是雪碧图-css-sprites-以及如何实现"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#请解释什么是雪碧图-css-sprites-以及如何实现"}},[e._v("#")]),e._v(" 请解释什么是雪碧图（css sprites），以及如何实现？")]),e._v(" "),a("p",[e._v("雪碧图是把多张图片整合到一张上的图片。它被运用在众多使用了很多小图标的网站上（Gmail 在使用）。实现方法：")]),e._v(" "),a("ol",[a("li",[e._v("使用生成器将多张图片打包成一张雪碧图，并为其生成合适的 CSS。")]),e._v(" "),a("li",[e._v("每张图片都有相应的 CSS 类，该类定义了"),a("code",[e._v("background-image")]),e._v("、"),a("code",[e._v("background-position")]),e._v("和"),a("code",[e._v("background-size")]),e._v("属性。")]),e._v(" "),a("li",[e._v("使用图片时，将相应的类添加到你的元素中。")])]),e._v(" "),a("p",[e._v("好处：")]),e._v(" "),a("ul",[a("li",[e._v("减少加载多张图片的 HTTP 请求数（一张雪碧图只需要一个请求）。但是对于 HTTP2 而言，加载多张图片不再是问题。")]),e._v(" "),a("li",[e._v("提前加载资源，防止在需要时才在开始下载引发的问题，比如只出现在"),a("code",[e._v(":hover")]),e._v("伪类中的图片，不会出现闪烁。")])]),e._v(" "),a("h3",{attrs:{id:"参考-6"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#参考-6"}},[e._v("#")]),e._v(" 参考")]),e._v(" "),a("ul",[a("li",[a("a",{attrs:{href:"https://css-tricks.com/css-sprites/",target:"_blank",rel:"noopener noreferrer"}},[e._v("https://css-tricks.com/css-sprites/"),a("OutboundLink")],1)])]),e._v(" "),a("h3",{attrs:{id:"如何解决不同浏览器的样式兼容性问题"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#如何解决不同浏览器的样式兼容性问题"}},[e._v("#")]),e._v(" 如何解决不同浏览器的样式兼容性问题？")]),e._v(" "),a("ul",[a("li",[e._v("在确定问题原因和有问题的浏览器后，使用单独的样式表，仅供出现问题的浏览器加载。这种方法需要使用服务器端渲染。")]),e._v(" "),a("li",[e._v("使用已经处理好此类问题的库，比如 Bootstrap。")]),e._v(" "),a("li",[e._v("使用 "),a("code",[e._v("autoprefixer")]),e._v(" 自动生成 CSS 属性前缀。")]),e._v(" "),a("li",[e._v("使用 Reset CSS 或 Normalize.css。")])]),e._v(" "),a("h3",{attrs:{id:"如何为功能受限的浏览器提供页面-使用什么样的技术和流程"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#如何为功能受限的浏览器提供页面-使用什么样的技术和流程"}},[e._v("#")]),e._v(" 如何为功能受限的浏览器提供页面？ 使用什么样的技术和流程？")]),e._v(" "),a("ul",[a("li",[e._v("优雅的降级：为现代浏览器构建应用，同时确保它在旧版浏览器中正常运行。")]),e._v(" "),a("li",[e._v("Progressive enhancement - The practice of building an application for a base level of user experience, but adding functional enhancements when a browser supports it.")]),e._v(" "),a("li",[e._v("渐进式增强：构建基于用户体验的应用，但在浏览器支持时添加新增功能。")]),e._v(" "),a("li",[e._v("利用 "),a("a",{attrs:{href:"https://caniuse.com/",target:"_blank",rel:"noopener noreferrer"}},[e._v("caniuse.com"),a("OutboundLink")],1),e._v(" 检查特性支持。")]),e._v(" "),a("li",[e._v("使用 "),a("code",[e._v("autoprefixer")]),e._v(" 自动生成 CSS 属性前缀。")]),e._v(" "),a("li",[e._v("使用 "),a("a",{attrs:{href:"https://modernizr.com/",target:"_blank",rel:"noopener noreferrer"}},[e._v("Modernizr"),a("OutboundLink")],1),e._v(" 进行特性检测。")])]),e._v(" "),a("h3",{attrs:{id:"有什么不同的方式可以隐藏内容-使其仅适用于屏幕阅读器"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#有什么不同的方式可以隐藏内容-使其仅适用于屏幕阅读器"}},[e._v("#")]),e._v(" 有什么不同的方式可以隐藏内容（使其仅适用于屏幕阅读器）？")]),e._v(" "),a("p",[e._v("这些方法与可访问性（a11y）有关。")]),e._v(" "),a("ul",[a("li",[a("code",[e._v("visibility: hidden")]),e._v("：元素仍然在页面流中，并占用空间。")]),e._v(" "),a("li",[a("code",[e._v("width: 0; height: 0")]),e._v("：使元素不占用屏幕上的任何空间，导致不显示它。")]),e._v(" "),a("li",[a("code",[e._v("position: absolute; left: -99999px")]),e._v("： 将它置于屏幕之外。")]),e._v(" "),a("li",[a("code",[e._v("text-indent: -9999px")]),e._v("：这只适用于"),a("code",[e._v("block")]),e._v("元素中的文本。")]),e._v(" "),a("li",[e._v("Metadata： 例如通过使用 "),a("a",{attrs:{href:"http://Schema.org",target:"_blank",rel:"noopener noreferrer"}},[e._v("http://Schema.org"),a("OutboundLink")],1),e._v("，RDF 和 JSON-LD。")]),e._v(" "),a("li",[e._v("WAI-ARIA：如何增加网页可访问性的 W3C 技术规范。")])]),e._v(" "),a("p",[e._v("即使 WAI-ARIA 是理想的解决方案，我也会采用绝对定位方法，因为它具有最少的注意事项，适用于大多数元素，而且使用起来非常简单。")]),e._v(" "),a("h3",{attrs:{id:"参考-7"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#参考-7"}},[e._v("#")]),e._v(" 参考")]),e._v(" "),a("ul",[a("li",[a("a",{attrs:{href:"https://www.w3.org/TR/wai-aria-1.1/",target:"_blank",rel:"noopener noreferrer"}},[e._v("https://www.w3.org/TR/wai-aria-1.1/"),a("OutboundLink")],1)]),e._v(" "),a("li",[a("a",{attrs:{href:"https://developer.mozilla.org/en-US/docs/Web/Accessibility/ARIA",target:"_blank",rel:"noopener noreferrer"}},[e._v("https://developer.mozilla.org/en-US/docs/Web/Accessibility/ARIA"),a("OutboundLink")],1)]),e._v(" "),a("li",[a("a",{attrs:{href:"http://a11yproject.com/",target:"_blank",rel:"noopener noreferrer"}},[e._v("http://a11yproject.com/"),a("OutboundLink")],1)])]),e._v(" "),a("h3",{attrs:{id:"除了screen-你还能说出一个-media-属性的例子吗"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#除了screen-你还能说出一个-media-属性的例子吗"}},[e._v("#")]),e._v(" 除了"),a("code",[e._v("screen")]),e._v("，你还能说出一个 @media 属性的例子吗？")]),e._v(" "),a("ul",[a("li",[e._v("all"),a("br"),e._v("\n适用于所有设备。")]),e._v(" "),a("li",[e._v("print"),a("br"),e._v("\n为了加载合适的文档到当前使用的可视窗口. 需要提前咨询 paged media（媒体屏幕尺寸）, 以满足个别设备网页尺寸不匹配等问题。")]),e._v(" "),a("li",[e._v("screen"),a("br"),e._v("\n主要适用于彩色的电脑屏幕")]),e._v(" "),a("li",[e._v("speech"),a("br"),e._v("\n解析 speech 这个合成器. 注意: CSS2 已经有一个相似的媒体类型叫 aural."),a("br"),e._v(" "),a("a",{attrs:{href:"https://developer.mozilla.org/zh-CN/docs/Web/CSS/@media",target:"_blank",rel:"noopener noreferrer"}},[e._v("https://developer.mozilla.org/zh-CN/docs/Web/CSS/@media"),a("OutboundLink")],1)])]),e._v(" "),a("h3",{attrs:{id:"编写高效的-css-应该注意什么"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#编写高效的-css-应该注意什么"}},[e._v("#")]),e._v(" 编写高效的 CSS 应该注意什么？")]),e._v(" "),a("p",[e._v("首先，浏览器从最右边的选择器，即关键选择器（key selector），向左依次匹配。根据关键选择器，浏览器从 DOM 中筛选出元素，然后向上遍历被选元素的父元素，判断是否匹配。选择器匹配语句链越短，浏览器的匹配速度越快。避免使用标签和通用选择器作为关键选择器，因为它们会匹配大量的元素，浏览器必须要进行大量的工作，去判断这些元素的父元素们是否匹配。")]),e._v(" "),a("p",[a("a",{attrs:{href:"https://bem.info/",target:"_blank",rel:"noopener noreferrer"}},[e._v("BEM (Block Element Modifier)"),a("OutboundLink")],1),e._v(" methodology recommends that everything has a single class, and, where you need hierarchy, that gets baked into the name of the class as well, this naturally makes the selector efficient and easy to override. "),a("a",{attrs:{href:"https://bem.info/",target:"_blank",rel:"noopener noreferrer"}},[e._v("BEM (Block Element Modifier)"),a("OutboundLink")],1),e._v(" 原则上建议为独立的 CSS 类命名，并且在需要层级关系时，将关系也体现在命名中，这自然会使选择器高效且易于覆盖。")]),e._v(" "),a("p",[e._v("搞清楚哪些 CSS 属性会触发重新布局（reflow）、重绘（repaint）和合成（compositing）。在写样式时，避免触发重新布局的可能。")]),e._v(" "),a("h3",{attrs:{id:"参考-8"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#参考-8"}},[e._v("#")]),e._v(" 参考")]),e._v(" "),a("ul",[a("li",[a("a",{attrs:{href:"https://developers.google.com/web/fundamentals/performance/rendering/",target:"_blank",rel:"noopener noreferrer"}},[e._v("https://developers.google.com/web/fundamentals/performance/rendering/"),a("OutboundLink")],1)]),e._v(" "),a("li",[a("a",{attrs:{href:"https://csstriggers.com/",target:"_blank",rel:"noopener noreferrer"}},[e._v("https://csstriggers.com/"),a("OutboundLink")],1)])]),e._v(" "),a("h3",{attrs:{id:"使用-css-预处理的优缺点分别是什么"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#使用-css-预处理的优缺点分别是什么"}},[e._v("#")]),e._v(" 使用 CSS 预处理的优缺点分别是什么？")]),e._v(" "),a("p",[e._v("优点：")]),e._v(" "),a("ul",[a("li",[e._v("提高 CSS 可维护性。")]),e._v(" "),a("li",[e._v("易于编写嵌套选择器。")]),e._v(" "),a("li",[e._v("引入变量，增添主题功能。可以在不同的项目中共享主题文件。")]),e._v(" "),a("li",[e._v("通过混合（Mixins）生成重复的 CSS。")]),e._v(" "),a("li",[e._v("Splitting your code into multiple files. CSS files can be split up too but doing so will require a HTTP request to download each CSS file.")]),e._v(" "),a("li",[e._v("将代码分割成多个文件。不进行预处理的 CSS，虽然也可以分割成多个文件，但需要建立多个 HTTP 请求加载这些文件。")])]),e._v(" "),a("p",[e._v("缺点：")]),e._v(" "),a("ul",[a("li",[e._v("需要预处理工具。")]),e._v(" "),a("li",[e._v("重新编译的时间可能会很慢。")])]),e._v(" "),a("h3",{attrs:{id:"对于你使用过的-css-预处理-说说喜欢和不喜欢的地方"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#对于你使用过的-css-预处理-说说喜欢和不喜欢的地方"}},[e._v("#")]),e._v(" 对于你使用过的 CSS 预处理，说说喜欢和不喜欢的地方？")]),e._v(" "),a("p",[e._v("喜欢：")]),e._v(" "),a("ul",[a("li",[e._v("绝大部分优点上题以及提过。")]),e._v(" "),a("li",[e._v("Less 用 JavaScript 实现，与 NodeJS 高度结合。")])]),e._v(" "),a("p",[a("strong",[e._v("Dislikes:")])]),e._v(" "),a("ul",[a("li",[e._v("我通过"),a("code",[e._v("node-sass")]),e._v("使用 Sass，它用 C ++ 编写的 LibSass 绑定。在 Node 版本切换时，我必须经常重新编译。")]),e._v(" "),a("li",[e._v("Less 中，变量名称以"),a("code",[e._v("@")]),e._v("作为前缀，容易与 CSS 关键字混淆，如"),a("code",[e._v("@media")]),e._v("、"),a("code",[e._v("@import")]),e._v("和"),a("code",[e._v("@font-face")]),e._v("。")])]),e._v(" "),a("h3",{attrs:{id:"如何实现一个使用非标准字体的网页设计"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#如何实现一个使用非标准字体的网页设计"}},[e._v("#")]),e._v(" 如何实现一个使用非标准字体的网页设计？")]),e._v(" "),a("p",[e._v("使用"),a("code",[e._v("@font-face")]),e._v("并为不同的"),a("code",[e._v("font-weight")]),e._v("定义"),a("code",[e._v("font-family")]),e._v("。")]),e._v(" "),a("h3",{attrs:{id:"解释浏览器如何确定哪些元素与-css-选择器匹配。"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#解释浏览器如何确定哪些元素与-css-选择器匹配。"}},[e._v("#")]),e._v(" 解释浏览器如何确定哪些元素与 CSS 选择器匹配。")]),e._v(" "),a("p",[e._v("这部分与上面关于编写高效的 CSS 有关。浏览器从最右边的选择器（关键选择器）根据关键选择器，浏览器从 DOM 中筛选出元素，然后向上遍历被选元素的父元素，判断是否匹配。选择器匹配语句链越短，浏览器的匹配速度越快。")]),e._v(" "),a("p",[e._v("例如，对于形如"),a("code",[e._v("p span")]),e._v("的选择器，浏览器首先找到所有"),a("code",[e._v("<span>")]),e._v("元素，并遍历它的父元素直到根元素以找到"),a("code",[e._v("<p>")]),e._v("元素。对于特定的"),a("code",[e._v("<span>")]),e._v("，只要找到一个"),a("code",[e._v("<p>")]),e._v("，就知道'` 已经匹配并停止继续匹配。")]),e._v(" "),a("h3",{attrs:{id:"参考-9"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#参考-9"}},[e._v("#")]),e._v(" 参考")]),e._v(" "),a("ul",[a("li",[a("a",{attrs:{href:"https://stackoverflow.com/questions/5797014/why-do-browsers-match-css-selectors-from-right-to-left",target:"_blank",rel:"noopener noreferrer"}},[e._v("https://stackoverflow.com/questions/5797014/why-do-browsers-match-css-selectors-from-right-to-left"),a("OutboundLink")],1)])]),e._v(" "),a("h3",{attrs:{id:"描述伪元素及其用途。"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#描述伪元素及其用途。"}},[e._v("#")]),e._v(" 描述伪元素及其用途。")]),e._v(" "),a("p",[e._v("CSS 伪元素是添加到选择器的关键字，去选择元素的特定部分。它们可以用于装饰（"),a("code",[e._v(":first-line")]),e._v("，"),a("code",[e._v(":first-letter")]),e._v("）或将元素添加到标记中（与 content:... 组合），而不必修改标记（"),a("code",[e._v(":before")]),e._v("，"),a("code",[e._v(":after")]),e._v("）。")]),e._v(" "),a("ul",[a("li",[a("code",[e._v(":first-line")]),e._v("和"),a("code",[e._v(":first-letter")]),e._v("可以用来修饰文字。")]),e._v(" "),a("li",[e._v("上面提到的"),a("code",[e._v(".clearfix")]),e._v("方法中，使用"),a("code",[e._v("clear: both")]),e._v("来添加不占空间的元素。")]),e._v(" "),a("li",[e._v("使用"),a("code",[e._v(":before")]),e._v("和"),a("code",[e._v("after")]),e._v("展示提示中的三角箭头。鼓励关注点分离，因为三角被视为样式的一部分，而不是真正的 DOM。如果不使用额外的 HTML 元素，只用 CSS 样式绘制三角形是不太可能的。")])]),e._v(" "),a("h3",{attrs:{id:"参考-10"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#参考-10"}},[e._v("#")]),e._v(" 参考")]),e._v(" "),a("ul",[a("li",[a("a",{attrs:{href:"https://css-tricks.com/almanac/selectors/a/after-and-before/",target:"_blank",rel:"noopener noreferrer"}},[e._v("https://css-tricks.com/almanac/selectors/a/after-and-before/"),a("OutboundLink")],1)])]),e._v(" "),a("h3",{attrs:{id:"说说你对盒模型的理解-以及如何告知浏览器使用不同的盒模型渲染布局。"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#说说你对盒模型的理解-以及如何告知浏览器使用不同的盒模型渲染布局。"}},[e._v("#")]),e._v(" 说说你对盒模型的理解，以及如何告知浏览器使用不同的盒模型渲染布局。")]),e._v(" "),a("p",[e._v("CSS 盒模型描述了以文档树中的元素而生成的矩形框，并根据排版模式进行布局。每个盒子都有一个内容区域（例如文本，图像等）以及周围可选的"),a("code",[e._v("padding")]),e._v("、"),a("code",[e._v("border")]),e._v("和"),a("code",[e._v("margin")]),e._v("区域。")]),e._v(" "),a("p",[e._v("CSS 盒模型负责计算：")]),e._v(" "),a("ul",[a("li",[e._v("块级元素占用多少空间。")]),e._v(" "),a("li",[e._v("边框是否重叠，边距是否合并。")]),e._v(" "),a("li",[e._v("盒子的尺寸。")])]),e._v(" "),a("p",[e._v("盒模型有以下规则：")]),e._v(" "),a("ul",[a("li",[e._v("块级元素的大小由"),a("code",[e._v("width")]),e._v("、"),a("code",[e._v("height")]),e._v("、"),a("code",[e._v("padding")]),e._v("、"),a("code",[e._v("border")]),e._v("和"),a("code",[e._v("margin")]),e._v("决定。")]),e._v(" "),a("li",[e._v("如果没有指定"),a("code",[e._v("height")]),e._v("，则块级元素的高度等于其包含子元素的内容高度加上"),a("code",[e._v("padding")]),e._v("（除非有浮动元素，请参阅下文）。")]),e._v(" "),a("li",[e._v("如果没有指定"),a("code",[e._v("width")]),e._v("，则非浮动块级元素的宽度等于其父元素的宽度减去父元素的"),a("code",[e._v("padding")]),e._v("。")]),e._v(" "),a("li",[e._v("元素的"),a("code",[e._v("height")]),e._v("是由内容的"),a("code",[e._v("height")]),e._v("来计算的。")]),e._v(" "),a("li",[e._v("元素的"),a("code",[e._v("width")]),e._v("是由内容的"),a("code",[e._v("width")]),e._v("来计算的。")]),e._v(" "),a("li",[e._v("默认情况下，"),a("code",[e._v("padding")]),e._v("和"),a("code",[e._v("border")]),e._v("不是元素"),a("code",[e._v("width")]),e._v("和"),a("code",[e._v("height")]),e._v("的组成部分。")])]),e._v(" "),a("h3",{attrs:{id:"参考-11"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#参考-11"}},[e._v("#")]),e._v(" 参考")]),e._v(" "),a("ul",[a("li",[a("a",{attrs:{href:"https://www.smashingmagazine.com/2010/06/the-principles-of-cross-browser-css-coding/#understand-the-css-box-model",target:"_blank",rel:"noopener noreferrer"}},[e._v("https://www.smashingmagazine.com/2010/06/the-principles-of-cross-browser-css-coding/#understand-the-css-box-model"),a("OutboundLink")],1)])]),e._v(" "),a("h3",{attrs:{id:"box-sizing-border-box-会产生怎样的效果"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#box-sizing-border-box-会产生怎样的效果"}},[e._v("#")]),e._v(" "),a("code",[e._v("* { box-sizing: border-box; }")]),e._v("会产生怎样的效果？")]),e._v(" "),a("ul",[a("li",[e._v("元素默认应用了"),a("code",[e._v("box-sizing: content-box")]),e._v("，元素的宽高只会决定内容（content）的大小。")]),e._v(" "),a("li",[a("code",[e._v("box-sizing: border-box")]),e._v("改变计算元素"),a("code",[e._v("width")]),e._v("和"),a("code",[e._v("height")]),e._v("的方式，"),a("code",[e._v("border")]),e._v("和"),a("code",[e._v("padding")]),e._v("的大小也将计算在内。")]),e._v(" "),a("li",[e._v("元素的"),a("code",[e._v("height")]),e._v(" = 内容（content）的高度 + 垂直方向的"),a("code",[e._v("padding")]),e._v(" + 垂直方向"),a("code",[e._v("border")]),e._v("的宽度")]),e._v(" "),a("li",[e._v("元素的"),a("code",[e._v("width")]),e._v(" = 内容（content）的宽度 + 水平方向的"),a("code",[e._v("padding")]),e._v(" + 水平方向"),a("code",[e._v("border")]),e._v("的宽度")])]),e._v(" "),a("h3",{attrs:{id:"display的属性值都有哪些"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#display的属性值都有哪些"}},[e._v("#")]),e._v(" "),a("code",[e._v("display")]),e._v("的属性值都有哪些？")]),e._v(" "),a("ul",[a("li",[a("code",[e._v("none")]),e._v(", "),a("code",[e._v("block")]),e._v(", "),a("code",[e._v("inline")]),e._v(", "),a("code",[e._v("inline-block")]),e._v(", "),a("code",[e._v("table")]),e._v(", "),a("code",[e._v("table-row")]),e._v(", "),a("code",[e._v("table-cell")]),e._v(", "),a("code",[e._v("list-item")]),e._v(".")])]),e._v(" "),a("h3",{attrs:{id:"inline和inline-block有什么区别"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#inline和inline-block有什么区别"}},[e._v("#")]),e._v(" "),a("code",[e._v("inline")]),e._v("和"),a("code",[e._v("inline-block")]),e._v("有什么区别？")]),e._v(" "),a("p",[e._v("我把"),a("code",[e._v("block")]),e._v("也加入其中，为了获得更好的比较。")]),e._v(" "),a("p",[e._v("| | "),a("code",[e._v("block")]),e._v(" | "),a("code",[e._v("inline-block")]),e._v(" | "),a("code",[e._v("inline")]),e._v(" | | ------------------------------- | ----------------------------------------------------------- | ------------------------------------------ | ------------------------------------------------------------------------------------------------------------------ | | 大小 | 填充其父容器的宽度。 | 取决于内容。 | 取决于内容。 | | 定位 | 从新的一行开始，并且不允许旁边有 HTML 元素（除非是"),a("code",[e._v("float")]),e._v("） | 与其他内容一起流动，并允许旁边有其他元素。 | 与其他内容一起流动，并允许旁边有其他元素。 | | 能否设置"),a("code",[e._v("width")]),e._v("和"),a("code",[e._v("height")]),e._v(" | 能 | 能 | 不能。 设置会被忽略。 | | 可以使用"),a("code",[e._v("vertical-align")]),e._v("对齐 | 不可以 | 可以 | 可以 | | 边距（margin）和填充（padding） | 各个方向都存在 | 各个方向都存在 | 只有水平方向存在。垂直方向会被忽略。 尽管"),a("code",[e._v("border")]),e._v("和"),a("code",[e._v("padding")]),e._v("在"),a("code",[e._v("content")]),e._v("周围，但垂直方向上的空间取决于'line-height' | | 浮动（float） | - | - | 就像一个"),a("code",[e._v("block")]),e._v("元素，可以设置垂直边距和填充。 |")]),e._v(" "),a("h3",{attrs:{id:"relative、fixed、absolute和static四种定位有什么区别"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#relative、fixed、absolute和static四种定位有什么区别"}},[e._v("#")]),e._v(" "),a("code",[e._v("relative")]),e._v("、"),a("code",[e._v("fixed")]),e._v("、"),a("code",[e._v("absolute")]),e._v("和"),a("code",[e._v("static")]),e._v("四种定位有什么区别？")]),e._v(" "),a("p",[e._v("经过定位的元素，其"),a("code",[e._v("position")]),e._v("属性值必然是"),a("code",[e._v("relative")]),e._v("、"),a("code",[e._v("absolute")]),e._v("、"),a("code",[e._v("fixed")]),e._v("或"),a("code",[e._v("sticky")]),e._v("。")]),e._v(" "),a("ul",[a("li",[a("code",[e._v("static")]),e._v("：默认定位属性值。该关键字指定元素使用正常的布局行为，即元素在文档常规流中当前的布局位置。此时 top, right, bottom, left 和 z-index 属性无效。")]),e._v(" "),a("li",[a("code",[e._v("relative")]),e._v("：该关键字下，元素先放置在未添加定位时的位置，再在不改变页面布局的前提下调整元素位置（因此会在此元素未添加定位时所在位置留下空白）。")]),e._v(" "),a("li",[a("code",[e._v("absolute")]),e._v("：不为元素预留空间，通过指定元素相对于最近的非 static 定位祖先元素的偏移，来确定元素位置。绝对定位的元素可以设置外边距（margins），且不会与其他边距合并。")]),e._v(" "),a("li",[a("code",[e._v("fixed")]),e._v("：不为元素预留空间，而是通过指定元素相对于屏幕视口（viewport）的位置来指定元素位置。元素的位置在屏幕滚动时不会改变。打印时，元素会出现在的每页的固定位置。fixed 属性会创建新的层叠上下文。当元素祖先的 transform 属性非 none 时，容器由视口改为该祖先。")]),e._v(" "),a("li",[a("code",[e._v("sticky")]),e._v("：盒位置根据正常流计算 (这称为正常流动中的位置)，然后相对于该元素在流中的 flow root（BFC）和 containing block（最近的块级祖先元素）定位。在所有情况下（即便被定位元素为 "),a("code",[e._v("table")]),e._v(" 时），该元素定位均不对后续元素造成影响。当元素 B 被粘性定位时，后续元素的位置仍按照 B 未定位时的位置来确定。"),a("code",[e._v("position: sticky")]),e._v(" 对 "),a("code",[e._v("table")]),e._v(" 元素的效果与 "),a("code",[e._v("position: relative")]),e._v(" 相同。")])]),e._v(" "),a("h3",{attrs:{id:"参考-12"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#参考-12"}},[e._v("#")]),e._v(" 参考")]),e._v(" "),a("ul",[a("li",[a("a",{attrs:{href:"https://developer.mozilla.org/en/docs/Web/CSS/position",target:"_blank",rel:"noopener noreferrer"}},[e._v("https://developer.mozilla.org/en/docs/Web/CSS/position"),a("OutboundLink")],1)])]),e._v(" "),a("h3",{attrs:{id:"你使用过哪些现有的-css-框架-你是如何改进它们的"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#你使用过哪些现有的-css-框架-你是如何改进它们的"}},[e._v("#")]),e._v(" 你使用过哪些现有的 CSS 框架？你是如何改进它们的？")]),e._v(" "),a("ul",[a("li",[a("strong",[e._v("Bootstrap")]),e._v("： 更新周期缓慢。Bootstrap 4 已经处于 alpha 版本将近两年了。添加了在页面中广泛使用的微调按钮组件。")]),e._v(" "),a("li",[a("strong",[e._v("Semantic UI")]),e._v("：源代码结构使得自定义主题很难理解。非常规主题系统的使用体验很差。外部库的路径需要硬编码（hard code）配置。变量重新赋值没有 Bootstrap 设计得好。")]),e._v(" "),a("li",[a("strong",[e._v("Bulma")]),e._v("： 需要很多非语义的类和标记，显得很多余。不向后兼容，以至于升级版本后，会破坏应用的正常运行。")])]),e._v(" "),a("h3",{attrs:{id:"你了解-css-flex-和-grid-吗"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#你了解-css-flex-和-grid-吗"}},[e._v("#")]),e._v(" 你了解 CSS Flex 和 Grid 吗？")]),e._v(" "),a("p",[e._v("Flex 主要用于一维布局，而 Grid 则用于二维布局。")]),e._v(" "),a("h3",{attrs:{id:"flex"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#flex"}},[e._v("#")]),e._v(" Flex")]),e._v(" "),a("p",[e._v("flex 容器中存在两条轴， 横轴和纵轴， 容器中的每个单元称为 flex item。")]),e._v(" "),a("p",[e._v("在容器上可以设置 6 个属性： "),a("em",[e._v("flex-direction")]),e._v(" flex-wrap "),a("em",[e._v("flex-flow")]),e._v(" justify-content "),a("em",[e._v("align-items")]),e._v(" align-content")]),e._v(" "),a("p",[e._v("注意：当设置 flex 布局之后，子元素的 float、clear、vertical-align 的属性将会失效。")]),e._v(" "),a("h3",{attrs:{id:"flex-项目属性"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#flex-项目属性"}},[e._v("#")]),e._v(" Flex 项目属性")]),e._v(" "),a("p",[e._v("有六种属性可运用在 item 项目上: 1. order 2. flex-basis 3. flex-grow 4. flex-shrink 5. flex 6. align-self")]),e._v(" "),a("h3",{attrs:{id:"grid"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#grid"}},[e._v("#")]),e._v(" Grid")]),e._v(" "),a("p",[e._v("CSS 网格布局用于将页面分割成数个主要区域，或者用来定义组件内部元素间大小、位置和图层之间的关系。")]),e._v(" "),a("p",[e._v("像表格一样，网格布局让我们能够按行或列来对齐元素。 但是，使用 CSS 网格可能还是比 CSS 表格更容易布局。 例如，网格容器的子元素可以自己定位，以便它们像 CSS 定位的元素一样，真正的有重叠和层次。")]),e._v(" "),a("h3",{attrs:{id:"响应式设计与自适应设计有何不同"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#响应式设计与自适应设计有何不同"}},[e._v("#")]),e._v(" 响应式设计与自适应设计有何不同？")]),e._v(" "),a("p",[e._v("响应式设计和自适应设计都以提高不同设备间的用户体验为目标，根据视窗大小、分辨率、使用环境和控制方式等参数进行优化调整。")]),e._v(" "),a("p",[e._v("响应式设计的适应性原则：网站应该凭借一份代码，在各种设备上都有良好的显示和使用效果。响应式网站通过使用媒体查询，自适应栅格和响应式图片，基于多种因素进行变化，创造出优良的用户体验。就像一个球通过膨胀和收缩，来适应不同大小的篮圈。")]),e._v(" "),a("p",[e._v("自适应设计更像是渐进式增强的现代解释。与响应式设计单一地去适配不同，自适应设计通过检测设备和其他特征，从早已定义好的一系列视窗大小和其他特性中，选出最恰当的功能和布局。与使用一个球去穿过各种的篮筐不同，自适应设计允许使用多个球，然后根据不同的篮筐大小，去选择最合适的一个。")]),e._v(" "),a("h3",{attrs:{id:"参考-13"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#参考-13"}},[e._v("#")]),e._v(" 参考")]),e._v(" "),a("ul",[a("li",[a("a",{attrs:{href:"https://developer.mozilla.org/en-US/docs/Archive/Apps/Design/UI_layout_basics/Responsive_design_versus_adaptive_design",target:"_blank",rel:"noopener noreferrer"}},[e._v("https://developer.mozilla.org/en-US/docs/Archive/Apps/Design/UI_layout_basics/Responsive_design_versus_adaptive_design"),a("OutboundLink")],1)]),e._v(" "),a("li",[a("a",{attrs:{href:"http://mediumwell.com/responsive-adaptive-mobile/",target:"_blank",rel:"noopener noreferrer"}},[e._v("http://mediumwell.com/responsive-adaptive-mobile/"),a("OutboundLink")],1)]),e._v(" "),a("li",[a("a",{attrs:{href:"https://css-tricks.com/the-difference-between-responsive-and-adaptive-design/",target:"_blank",rel:"noopener noreferrer"}},[e._v("https://css-tricks.com/the-difference-between-responsive-and-adaptive-design/"),a("OutboundLink")],1)])]),e._v(" "),a("h3",{attrs:{id:"你有没有使用过视网膜分辨率的图形-当中使用什么技术"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#你有没有使用过视网膜分辨率的图形-当中使用什么技术"}},[e._v("#")]),e._v(" 你有没有使用过视网膜分辨率的图形？当中使用什么技术？")]),e._v(" "),a("p",[e._v("我倾向于使用更高分辨率的图形（显示尺寸的两倍）来处理视网膜显示。更好的方法是使用媒体查询，像"),a("code",[e._v("@media only screen and (min-device-pixel-ratio: 2) { ... }")]),e._v("，然后改变"),a("code",[e._v("background-image")]),e._v("。")]),e._v(" "),a("p",[e._v("对于图标类的图形，我会尽可能使用 svg 和图标字体，因为它们在任何分辨率下，都能被渲染得十分清晰。")]),e._v(" "),a("p",[e._v("还有一种方法是，在检查了"),a("code",[e._v("window.devicePixelRatio")]),e._v("的值后，利用 JavaScript 将"),a("code",[e._v("<img>")]),e._v("的"),a("code",[e._v("src")]),e._v("属性修改，用更高分辨率的版本进行替换。")]),e._v(" "),a("h3",{attrs:{id:"参考-14"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#参考-14"}},[e._v("#")]),e._v(" 参考")]),e._v(" "),a("ul",[a("li",[a("a",{attrs:{href:"https://www.sitepoint.com/css-techniques-for-retina-displays/",target:"_blank",rel:"noopener noreferrer"}},[e._v("https://www.sitepoint.com/css-techniques-for-retina-displays/"),a("OutboundLink")],1)])]),e._v(" "),a("h3",{attrs:{id:"什么情况下-用translate-而不用绝对定位-什么时候-情况相反。"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#什么情况下-用translate-而不用绝对定位-什么时候-情况相反。"}},[e._v("#")]),e._v(" 什么情况下，用"),a("code",[e._v("translate()")]),e._v("而不用绝对定位？什么时候，情况相反。")]),e._v(" "),a("p",[a("code",[e._v("translate()")]),e._v("是"),a("code",[e._v("transform")]),e._v("的一个值。改变"),a("code",[e._v("transform")]),e._v("或"),a("code",[e._v("opacity")]),e._v("不会触发浏览器重新布局（reflow）或重绘（repaint），只会触发复合（compositions）。而改变绝对定位会触发重新布局，进而触发重绘和复合。"),a("code",[e._v("transform")]),e._v("使浏览器为元素创建一个 GPU 图层，但改变绝对定位会使用到 CPU。 因此"),a("code",[e._v("translate()")]),e._v("更高效，可以缩短平滑动画的绘制时间。")]),e._v(" "),a("p",[e._v("当使用"),a("code",[e._v("translate()")]),e._v("时，元素仍然占据其原始空间（有点像"),a("code",[e._v("position：relative")]),e._v("），这与改变绝对定位不同。")]),e._v(" "),a("h3",{attrs:{id:"参考-15"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#参考-15"}},[e._v("#")]),e._v(" 参考")]),e._v(" "),a("ul",[a("li",[a("a",{attrs:{href:"https://www.paulirish.com/2012/why-moving-elements-with-translate-is-better-than-posabs-topleft/",target:"_blank",rel:"noopener noreferrer"}},[e._v("https://www.paulirish.com/2012/why-moving-elements-with-translate-is-better-than-posabs-topleft/"),a("OutboundLink")],1)])]),e._v(" "),a("h3",{attrs:{id:"其他答案"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#其他答案"}},[e._v("#")]),e._v(" 其他答案")]),e._v(" "),a("ul",[a("li",[a("a",{attrs:{href:"https://neal.codes/blog/front-end-interview-css-questions",target:"_blank",rel:"noopener noreferrer"}},[e._v("https://neal.codes/blog/front-end-interview-css-questions"),a("OutboundLink")],1)]),e._v(" "),a("li",[a("a",{attrs:{href:"https://quizlet.com/28293152/front-end-interview-questions-css-flash-cards/",target:"_blank",rel:"noopener noreferrer"}},[e._v("https://quizlet.com/28293152/front-end-interview-questions-css-flash-cards/"),a("OutboundLink")],1)]),e._v(" "),a("li",[a("a",{attrs:{href:"http://peterdoes.it/2015/12/03/a-personal-exercise-front-end-job-interview-questions-and-my-answers-all/",target:"_blank",rel:"noopener noreferrer"}},[e._v("http://peterdoes.it/2015/12/03/a-personal-exercise-front-end-job-interview-questions-and-my-answers-all/"),a("OutboundLink")],1)])]),e._v(" "),a("h3",{attrs:{id:"行内元素、块级元素区别"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#行内元素、块级元素区别"}},[e._v("#")]),e._v(" 行内元素、块级元素区别")]),e._v(" "),a("p",[e._v("行内元素：和其他元素都在一行上，高度、行高及外边距和内边距都不可改变，文字图片的宽度不可改变，只能容纳文本或者其他行内元素；其中 img 是行元素")]),e._v(" "),a("p",[e._v("块级元素：总是在新行上开始，高度、行高及外边距和内边距都可控制，可以容纳内敛元素和其他元素；行元素转换为块级元素方式：display：block；")]),e._v(" "),a("h3",{attrs:{id:"一边固定宽度一边宽度自适应"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#一边固定宽度一边宽度自适应"}},[e._v("#")]),e._v(" 一边固定宽度一边宽度自适应")]),e._v(" "),a("p",[e._v("可以使用 flex 布局 复制下面的 HTML 和 CSS 代码 用浏览器打开可以看到效果")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("<div>\n  <div></div>\n  <div></div>\n</div>\n\n.wrap {\n  display: flex;\n  justify-content: space-between;\n}\n.div1 {\n  min-width: 200px;\n}\n.div2 {\n  width: 100%;\n  background: #e6e6e6;\n}\nhtml,\nbody,\ndiv {\n  height: 100%;\n  margin: 0;\n}\n")])])]),a("h3",{attrs:{id:"水平垂直居中的方式"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#水平垂直居中的方式"}},[e._v("#")]),e._v(" 水平垂直居中的方式")]),e._v(" "),a("h3",{attrs:{id:"flex-2"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#flex-2"}},[e._v("#")]),e._v(" flex")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("// 父容器\ndisplay: flex;\njustify-content: center;\nalign-items: center;\n")])])]),a("h3",{attrs:{id:"position"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#position"}},[e._v("#")]),e._v(" position")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("// 父容器\nposition: relative;\n\n// 子容器\nposition:absolute;\nmargin:auto;\ntop:0;\nbottom:0;\nleft:0;\nright:0;\n")])])]),a("h3",{attrs:{id:"position-transform"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#position-transform"}},[e._v("#")]),e._v(" position+transform")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("// 父容器\nposition: relative;\n\n// 子容器\nposition: absolute;\ntop: 50%;\nleft: 50%;\ntransform: translate(-50%, -50%);\n")])])]),a("h3",{attrs:{id:"table-cell"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#table-cell"}},[e._v("#")]),e._v(" table-cell")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("<div>\n    <div>\n        <div></div>\n    </div>\n</div>\n\nhtml, body {\n    height: 100%;\n    width: 100%;\n    margin: 0;\n}\n.box {\n    display: table;\n    height: 100%;\n    width: 100%;\n}\n.content {\n    display: table-cell;\n    vertical-align: middle;\n    text-align: center;\n}\n.inner {\n    background-color: #000;\n    display: inline-block;\n    width: 200px;\n    height: 200px;\n}\n")])])]),a("h3",{attrs:{id:"display-none、visibile-hidden、opacity-0-的区别"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#display-none、visibile-hidden、opacity-0-的区别"}},[e._v("#")]),e._v(" display:none、visibile:hidden、opacity:0 的区别")]),e._v(" "),a("p",[e._v("| | 是否隐藏 | 是否在文档中占用空间 | 是否会触发事件 | |-|-|-|-| |display: none | 是 | 否 | 否 | |visibile: hidden | 是 | 是 | 否 | |opacity: 0 | 是 | 是 | 是 |")]),e._v(" "),a("h3",{attrs:{id:"css-中-link-和-import-的区别"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#css-中-link-和-import-的区别"}},[e._v("#")]),e._v(" CSS 中 link 和 @import 的区别")]),e._v(" "),a("ul",[a("li",[e._v("link 属于 HTML 标签，而 @import 是 CSS 提供的")]),e._v(" "),a("li",[e._v("页面被加载的时，link 会同时被加载，而 @import 引用的 CSS 会等到页面被加载完再加载")]),e._v(" "),a("li",[e._v("import 只在 IE5 以上才能识别，而 link 是 HTML 标签，无兼容问题")]),e._v(" "),a("li",[e._v("link 方式的样式的权重 高于 @import 的权重")])]),e._v(" "),a("h3",{attrs:{id:"如何用-css-实现瀑布流布局"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#如何用-css-实现瀑布流布局"}},[e._v("#")]),e._v(" 如何用 css 实现瀑布流布局")]),e._v(" "),a("p",[e._v("利用 column-count 和 break-inside 这两个 CSS3 属性即可，复制如下代码即可察看效果")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v('<!DOCTYPE html>\n<html>\n<head>\n    <meta charset="utf-8">\n    <style>\n        body {\n            margin: 0;\n        }\n        .waterfall-container {\n            /*分几列*/\n            column-count: 2;\n            width: 100%;\n            /* 列间距 */\n            column-gap: 10px;\n        }\n\n        .waterfall-item {\n            break-inside: avoid;\n            width: 100%;\n            height: 100px;\n            margin-bottom: 10px;\n            background: #ddd;\n            column-gap: 0;\n            text-align: center;\n            color: #fff;\n            font-size: 40px;\n        }\n    </style>\n</head>\n<body>\n    <div>\n        <div>1</div>\n        <div>2</div>\n        <div>3</div>\n        <div>4</div>\n        <div>5</div>\n        <div>6</div>\n        <div>7</div>\n        <div>8</div>\n        <div>9</div>\n        <div>10</div>\n    </div>\n</body>\n</html>\n')])])]),a("h2",{attrs:{id:"文本超出部分显示省略号"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#文本超出部分显示省略号"}},[e._v("#")]),e._v(" 文本超出部分显示省略号")]),e._v(" "),a("h3",{attrs:{id:"单行"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#单行"}},[e._v("#")]),e._v(" 单行")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("overflow: hidden;\ntext-overflow:ellipsis;\nwhite-space: nowrap;\n")])])]),a("h3",{attrs:{id:"多行"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#多行"}},[e._v("#")]),e._v(" 多行")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("display: -webkit-box;\n-webkit-box-orient: vertical;\n-webkit-line-clamp: 3; // 最多显示几行\noverflow: hidden;\n")])])]),a("h2",{attrs:{id:"利用伪元素画三角"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#利用伪元素画三角"}},[e._v("#")]),e._v(" 利用伪元素画三角")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v(".info-tab {\n    position: relative;\n}\n.info-tab::after {\n    content: '';\n    border: 4px solid transparent;\n    border-top-color: #2c8ac2;\n    position: absolute;\n    top: 0;\n}\n")])])]),a("h2",{attrs:{id:"已知父级盒子的宽高-子级-img-宽高未知-想让-img-铺满父级盒子且图片不能变形"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#已知父级盒子的宽高-子级-img-宽高未知-想让-img-铺满父级盒子且图片不能变形"}},[e._v("#")]),e._v(" 已知父级盒子的宽高，子级 img 宽高未知，想让 img 铺满父级盒子且图片不能变形")]),e._v(" "),a("p",[e._v("需要用到"),a("code",[e._v("css")]),e._v("的"),a("code",[e._v("object-fit")]),e._v("属性")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("div {\n    width: 200px;\n    height: 200px;\n}\nimg {\n    object-fit: cover;\n    width: 100%;\n    height: 100%;\n}\n")])])]),a("p",[a("a",{attrs:{href:"https://developer.mozilla.org/zh-CN/docs/Web/CSS/object-fit",target:"_blank",rel:"noopener noreferrer"}},[e._v("MDN"),a("OutboundLink")],1)]),e._v(" "),a("h2",{attrs:{id:"iframe-的作用"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#iframe-的作用"}},[e._v("#")]),e._v(" iframe 的作用")]),e._v(" "),a("p",[e._v("iframe 是用来在网页中插入第三方页面，早期的页面使用 iframe 主要是用于导航栏这种很多页面都相同的部分，这样在切换页面的时候避免重复下载。")]),e._v(" "),a("p",[e._v("优点 1. 便于修改，模拟分离，像一些信息管理系统会用到。 2. 但现在基本不推荐使用。除非特殊需要，一般不推荐使用。")]),e._v(" "),a("p",[e._v("缺点 1. iframe 的创建比一般的 DOM 元素慢了 1-2 个数量级 2. iframe 标签会阻塞页面的的加载，如果页面的 onload 事件不能及时触发，会让用户觉得网页加载很慢，用户体验不好，在 Safari 和 Chrome 中可以通过 js 动态设置 iframe 的 src 属性来避免阻塞。 3. iframe 对于 SEO 不友好，替换方案一般就是动态语言的 Incude 机制和 ajax 动态填充内容等。")]),e._v(" "),a("h2",{attrs:{id:"css-hack-是什么"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#css-hack-是什么"}},[e._v("#")]),e._v(" css hack 是什么")]),e._v(" "),a("p",[e._v("由于不同的浏览器，比如 Internet Explorer 6,Internet Explorer 7,Mozilla Firefox 等，对 CSS 的解析认识不一样，因此会导致生成的页面效果不一样，得不到我们所需要的页面效果。")]),e._v(" "),a("p",[e._v("这个时候我们就需要针对不同的浏览器去写不同的 CSS，让它能够同时兼容不同的浏览器，能在不同的浏览器中也能得到我们想要的页面效果。")]),e._v(" "),a("p",[e._v("这个针对不同的浏览器写不同的 CSS code 的过程，就叫 CSS hack, 也叫写 CSS hack。")]),e._v(" "),a("p",[e._v("具体请看："),a("br"),e._v(" "),a("a",{attrs:{href:"http://www.cnblogs.com/Renyi-Fan/p/9006084.html",target:"_blank",rel:"noopener noreferrer"}},[e._v("http://www.cnblogs.com/Renyi-Fan/p/9006084.html"),a("OutboundLink")],1)]),e._v(" "),a("h2",{attrs:{id:"过渡与动画的区别是什么"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#过渡与动画的区别是什么"}},[e._v("#")]),e._v(" 过渡与动画的区别是什么")]),e._v(" "),a("ul",[a("li",[e._v("transition"),a("br"),e._v("\n可以在一定的时间内实现元素的状态过渡为最终状态，用于模拟以一种过渡动画效果，但是功能有限，只能用于制作简单的动画效果而动画属性")]),e._v(" "),a("li",[e._v("animation"),a("br"),e._v("\n可以制作类似 Flash 动画，通过关键帧控制动画的每一步，控制更为精确，从而可以制作更为复杂的动画。")])]),e._v(" "),a("h2",{attrs:{id:"什么是外边距合并"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#什么是外边距合并"}},[e._v("#")]),e._v(" 什么是外边距合并")]),e._v(" "),a("p",[e._v("外边距合并指的是，当两个垂直外边距相遇时，它们将形成一个外边距。")]),e._v(" "),a("p",[e._v("合并后的外边距的高度等于两个发生合并的外边距的高度中的较大者。")]),e._v(" "),a("h2",{attrs:{id:"去除-inline-block-元素间间距的方法"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#去除-inline-block-元素间间距的方法"}},[e._v("#")]),e._v(" 去除 inline-block 元素间间距的方法")]),e._v(" "),a("ul",[a("li",[e._v("移除空格")]),e._v(" "),a("li",[e._v("使用 margin 负值")]),e._v(" "),a("li",[e._v("使用 font-size:0")]),e._v(" "),a("li",[e._v("letter-spacing")]),e._v(" "),a("li",[e._v("word-spacing")])]),e._v(" "),a("p",[e._v("更详细的介绍请看: "),a("a",{attrs:{href:"https://www.zhangxinxu.com/wordpress/2012/04/inline-block-space-remove-%E5%8E%BB%E9%99%A4%E9%97%B4%E8%B7%9D/",target:"_blank",rel:"noopener noreferrer"}},[e._v("去除 inline-block 元素间间距的 N 种方法"),a("OutboundLink")],1)]),e._v(" "),a("h2",{attrs:{id:"javascript-问题"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#javascript-问题"}},[e._v("#")]),e._v(" JavaScript 问题")]),e._v(" "),a("h2",{attrs:{id:"同源策略"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#同源策略"}},[e._v("#")]),e._v(" 同源策略")]),e._v(" "),a("p",[e._v("同源策略可防止 JavaScript 发起跨域请求。源被定义为 URI、主机名和端口号的组合。此策略可防止页面上的恶意脚本通过该页面的文档对象模型，访问另一个网页上的敏感数据。")]),e._v(" "),a("h2",{attrs:{id:"跨域"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#跨域"}},[e._v("#")]),e._v(" 跨域")]),e._v(" "),a("ul",[a("li",[e._v("原因"),a("br"),e._v("\n浏览器的同源策略导致了跨域")]),e._v(" "),a("li",[e._v("作用"),a("br"),e._v("\n用于隔离潜在恶意文件的重要安全机制")]),e._v(" "),a("li",[e._v("解决")]),e._v(" "),a("li",[e._v("jsonp ，允许 script 加载第三方资源")]),e._v(" "),a("li",[e._v("反向代理（nginx 服务内部配置 Access-Control-Allow-Origin *）")]),e._v(" "),a("li",[e._v("cors 前后端协作设置请求头部，Access-Control-Allow-Origin 等头部信息")]),e._v(" "),a("li",[e._v("iframe 嵌套通讯，postmessage")])]),e._v(" "),a("p",[a("a",{attrs:{href:"https://zhuanlan.zhihu.com/p/41479807",target:"_blank",rel:"noopener noreferrer"}},[e._v("https://zhuanlan.zhihu.com/p/41479807"),a("OutboundLink")],1),a("br"),e._v(" "),a("a",{attrs:{href:"http://www.ruanyifeng.com/blog/2016/04/cors.html",target:"_blank",rel:"noopener noreferrer"}},[e._v("跨域资源共享 CORS 阮一峰"),a("OutboundLink")],1)]),e._v(" "),a("h2",{attrs:{id:"jsonp"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#jsonp"}},[e._v("#")]),e._v(" JSONP")]),e._v(" "),a("p",[e._v("这是我认为写得比较通俗易懂的一篇文章 直接转载过来"),a("br"),e._v(" "),a("a",{attrs:{href:"https://blog.csdn.net/hansexploration/article/details/80314948",target:"_blank",rel:"noopener noreferrer"}},[e._v("https://blog.csdn.net/hansexploration/article/details/80314948"),a("OutboundLink")],1)]),e._v(" "),a("h2",{attrs:{id:"域名收敛"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#域名收敛"}},[e._v("#")]),e._v(" 域名收敛")]),e._v(" "),a("p",[e._v("PC 时代为了突破浏览器的域名并发限制。有了域名发散。"),a("br"),e._v("\n浏览器有并发限制，是为了防止 DDOS 攻击。"),a("br"),e._v("\n域名收敛：就是将静态资源放在一个域名下。减少 DNS 解析的开销。"),a("br"),e._v("\n域名发散：是将静态资源放在多个子域名下，就可以多线程下载，提高并行度，使客户端加载静态资源更加迅速。"),a("br"),e._v("\n域名发散是 pc 端为了利用浏览器的多线程并行下载能力。而域名收敛多用与移动端，提高性能，因为 dns 解析是是从后向前迭代解析，如果域名过多性能会下降，增加 DNS 的解析开销。")]),e._v(" "),a("h2",{attrs:{id:"事件绑定的方式"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#事件绑定的方式"}},[e._v("#")]),e._v(" 事件绑定的方式")]),e._v(" "),a("ul",[a("li",[e._v("嵌入 dom")])]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v('<button onclick="func()">按钮</button>\n')])])]),a("ul",[a("li",[e._v("直接绑定")])]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("btn.onclick = function(){}\n")])])]),a("ul",[a("li",[e._v("事件监听")])]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("btn.addEventListener('click',function(){})\n")])])]),a("h2",{attrs:{id:"事件委托"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#事件委托"}},[e._v("#")]),e._v(" 事件委托")]),e._v(" "),a("p",[e._v("事件委托利用了事件冒泡，只指定一个事件处理程序，就可以管理某一类型的所有事件。所有用到按钮的事件（多数鼠标事件和键盘事件）都适合采用事件委托技术， 使用事件委托可以节省内存。")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("<ul>\n  <li>苹果</li>\n  <li>香蕉</li>\n  <li>凤梨</li>\n</ul>\n\n// good\ndocument.querySelector('ul').onclick = (event) => {\n  let target = event.target\n  if (target.nodeName === 'LI') {\n    console.log(target.innerHTML)\n  }\n}\n\n// bad\ndocument.querySelectorAll('li').forEach((e) => {\n  e.onclick = function() {\n    console.log(this.innerHTML)\n  }\n})\n")])])]),a("h2",{attrs:{id:"事件循环"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#事件循环"}},[e._v("#")]),e._v(" 事件循环")]),e._v(" "),a("p",[e._v("事件循环是一个单线程循环，用于监视调用堆栈并检查是否有工作即将在任务队列中完成。如果调用堆栈为空并且任务队列中有回调函数，则将回调函数出队并推送到调用堆栈中执行。")]),e._v(" "),a("h2",{attrs:{id:"事件模型"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#事件模型"}},[e._v("#")]),e._v(" 事件模型")]),e._v(" "),a("ul",[a("li",[e._v("DOM0"),a("br"),e._v("\n直接绑定")])]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v('<input onclick="sayHi()"/>\n\nbtn.onclick = function() {}\nbtn.onclick = null\n')])])]),a("ul",[a("li",[e._v("DOM2"),a("br"),e._v("\nDOM2 级事件可以冒泡和捕获 通过 addEventListener 绑定 通过 removeEventListener 解绑")])]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("// 绑定\nbtn.addEventListener('click', sayHi)\n// 解绑\nbtn.removeEventListener('click', sayHi)\n")])])]),a("ul",[a("li",[e._v("DOM3"),a("br"),e._v("\nDOM3 具有更多事件类型 DOM3 级事件在 DOM2 级事件的基础上添加了更多的事件类型，全部类型如下：")])]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("UI事件，当用户与页面上的元素交互时触发，如：load、scroll\n焦点事件，当元素获得或失去焦点时触发，如：blur、focus\n鼠标事件，当用户通过鼠标在页面执行操作时触发如：dbclick、mouseup\n滚轮事件，当使用鼠标滚轮或类似设备时触发，如：mousewheel\n文本事件，当在文档中输入文本时触发，如：textInput\n键盘事件，当用户通过键盘在页面上执行操作时触发，如：keydown、keypress\n合成事件，当为IME（输入法编辑器）输入字符时触发，如：compositionstart\n变动事件，当底层DOM结构发生变化时触发，如：DOMsubtreeModified\n")])])]),a("p",[a("a",{attrs:{href:"https://www.jianshu.com/p/3acdf5f71d5b",target:"_blank",rel:"noopener noreferrer"}},[e._v("https://www.jianshu.com/p/3acdf5f71d5b"),a("OutboundLink")],1)]),e._v(" "),a("h2",{attrs:{id:"如何自定义事件"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#如何自定义事件"}},[e._v("#")]),e._v(" 如何自定义事件")]),e._v(" "),a("ol",[a("li",[e._v("原生提供了 3 个方法实现自定义事件")]),e._v(" "),a("li",[e._v("createEvent，设置事件类型，是 html 事件还是 鼠标事件")]),e._v(" "),a("li",[e._v("initEvent 初始化事件，事件名称，是否允许冒泡，是否阻止自定义事件")]),e._v(" "),a("li",[e._v("dispatchEvent 触发事件")])]),e._v(" "),a("p",[a("a",{attrs:{href:"https://developer.mozilla.org/zh-CN/docs/Web/Guide/Events/Creating_and_triggering_events",target:"_blank",rel:"noopener noreferrer"}},[e._v("MDN"),a("OutboundLink")],1)]),e._v(" "),a("h2",{attrs:{id:"target-和-currenttarget-区别"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#target-和-currenttarget-区别"}},[e._v("#")]),e._v(" target 和 currentTarget 区别")]),e._v(" "),a("ul",[a("li",[e._v("event.target"),a("br"),e._v("\n返回触发事件的元素")]),e._v(" "),a("li",[e._v("event.currentTarget"),a("br"),e._v("\n返回绑定事件的元素")])]),e._v(" "),a("h2",{attrs:{id:"prototype-和-proto-的关系是什么"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#prototype-和-proto-的关系是什么"}},[e._v("#")]),e._v(" prototype 和__proto__的关系是什么")]),e._v(" "),a("p",[e._v("每个实例对象都有一个私有属性 "),a("code",[e._v("__proto__")]),e._v("，它指向对象构造函数的 "),a("code",[e._v("prototype")]),e._v(" 属性；但是 "),a("code",[e._v("Object.create(null)")]),e._v(" 创建的对象除外，它没有 "),a("code",[e._v("__proto__")]),e._v(" 属性，也没有 "),a("code",[e._v("prototype")]),e._v(" 属性。")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("const obj = {}\nobj.__proto__ === Object.prototype // true\n\nfunction Test(){}\ntest.__proto__ == Test.prototype // true\n\nconst obj2 = Object.create(null)\nobj2.__proto__ // undefined\nobj2.prototype // undefined\n")])])]),a("p",[e._v("所有的函数都同时拥有 "),a("code",[e._v("__proto__")]),e._v(" 和 "),a("code",[e._v("protytpe")]),e._v(" 属性。")]),e._v(" "),a("p",[e._v("函数的 "),a("code",[e._v("__proto__")]),e._v(" 指向自己的函数实现，而 "),a("code",[e._v("protytpe")]),e._v(" 是一个对象， 所以函数的 "),a("code",[e._v("prototype")]),e._v(" 也有 "),a("code",[e._v("__proto__")]),e._v(" 属性，指向 "),a("code",[e._v("Object.prototype")]),e._v("。")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("function func() {}\nfunc.prototype.__proto__ === Object.prototype // true\n")])])]),a("p",[a("code",[e._v("Object.prototype.__proto__")]),e._v(" 指向 null")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("Object.prototype.__proto__ // null\n")])])]),a("h2",{attrs:{id:"原型继承"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#原型继承"}},[e._v("#")]),e._v(" 原型继承")]),e._v(" "),a("p",[e._v("所有的 JS 对象都有一个 prototype 属性，指向它的原型对象。当试图访问一个对象的属性时，如果没有在该对象上找到，它还会搜寻该对象的原型，以及该对象的原型的原型，依次层层向上搜索，直到找到一个名字匹配的属性或到达原型链的末尾。")]),e._v(" "),a("h2",{attrs:{id:"继承"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#继承"}},[e._v("#")]),e._v(" 继承")]),e._v(" "),a("p",[e._v("JS 高程第 3 版 第 6 章 继承 寄生组合式继承")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("function SuperType(name) {\n    this.name = name\n    this.colors = ['red']\n}\n\nSuperType.prototype.sayName = function() {\n    console.log(this.name)\n}\n// 继承实例属性\nfunction SubType(name, age) {\n    SuperType.call(this, name)\n    this.age = age\n}\n\nfunction inheritPrototype(subType, superType) {\n    let prototype = Object.create(superType.prototype)\n    prototype.constructor = subType\n    subType.prototype = prototype\n}\n// 继承原型方法\ninheritPrototype(SubType, SuperType)\n\n// 定义自己的原型方法\nSubType.prototype.sayAge = function() {\n    console.log(this.age)\n}\n")])])]),a("h2",{attrs:{id:"闭包"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#闭包"}},[e._v("#")]),e._v(" 闭包")]),e._v(" "),a("p",[e._v("闭包是指有权访问另一个函数作用域中的变量的函数。")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("function sayHi(name) {\n    return () => {\n       console.log(`Hi! ${name}`)\n    }\n}\nconst test = sayHi('xiaoming')\ntest() // Hi! xiaoming\n")])])]),a("p",[e._v("虽然 sayHi 函数已经执行完毕，但是其活动对象也不会被销毁，因为 test 函数仍然引用着 sayHi 函数中的变量 name，这就是闭包。"),a("br"),e._v("\n但也因为闭包引用着另一个函数的变量，导致另一个函数已经不使用了也无法销毁，所以闭包使用过多，会占用较多的内存，这也是一个副作用。")]),e._v(" "),a("h2",{attrs:{id:"有一个函数-参数是一个函数-返回值也是一个函数-返回的函数功能和入参的函数相似-但这个函数只能执行-3-次-再次执行无效-如何实现"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#有一个函数-参数是一个函数-返回值也是一个函数-返回的函数功能和入参的函数相似-但这个函数只能执行-3-次-再次执行无效-如何实现"}},[e._v("#")]),e._v(" 有一个函数，参数是一个函数，返回值也是一个函数，返回的函数功能和入参的函数相似，但这个函数只能执行 3 次，再次执行无效，如何实现")]),e._v(" "),a("p",[e._v("这个题目是考察闭包的使用")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("function sayHi() {\n    console.log('hi')\n}\n\nfunction threeTimes(fn) {\n    let times = 0\n    return () => {\n        if (times++ < 3) {\n            fn()\n        }\n    }\n}\n\nconst newFn = threeTimes(sayHi)\nnewFn()\nnewFn()\nnewFn()\nnewFn()\nnewFn() // 后面两次执行都无任何反应\n")])])]),a("p",[e._v("通过闭包变量 "),a("code",[e._v("times")]),e._v(" 来控制函数的执行")]),e._v(" "),a("h2",{attrs:{id:"实现-add-函数-让-add-a-b-和-add-a-b-两种调用结果相同"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#实现-add-函数-让-add-a-b-和-add-a-b-两种调用结果相同"}},[e._v("#")]),e._v(" 实现 add 函数, 让 add(a)(b) 和 add(a,b) 两种调用结果相同")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("function add(a, b) {\n    if (b === undefined) {\n        return function(x) {\n            return a + x\n        }\n    }\n\n    return a + b\n}\n")])])]),a("h2",{attrs:{id:"ajax"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#ajax"}},[e._v("#")]),e._v(" Ajax")]),e._v(" "),a("p",[e._v("Ajax(asynchronous JavaScript and XML) 是使用客户端上的许多 Web 技术，创建异步 Web 应用的一种 Web 开发技术。借助 Ajax，Web 应用可以异步（在后台）向服务器发送数据和从服务器检索数据，而不会干扰现有页面的显示和行为。通过将数据交换层与表示层分离，Ajax 允许网页和扩展 Web 应用程序动态更改内容，而无需重新加载整个页面。实际上，现在通常将 JSON 替换为 XML，因为 JavaScript 对 JSON 有原生支持优势。"),a("br"),e._v("\nXMLHttpRequest API 经常用于异步通信。此外还有最近流行的 fetch API。")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v('let xmlhttp\nif (window.XMLHttpRequest) {\n    //  IE7+, Firefox, Chrome, Opera, Safari 浏览器执行代码\n    xmlhttp = new XMLHttpRequest()\n} else {\n    // IE6, IE5 浏览器执行代码\n    xmlhttp = new ActiveXObject("Microsoft.XMLHTTP")\n}\nxmlhttp.onreadystatechange = () => {\n    if (xmlhttp.readyState === 4 && xmlhttp.status === 200) {\n        document.getElementById("myDiv").innerHTML = xmlhttp.responseText\n    }\n}\nxmlhttp.open("GET", "/ajax/test.txt", true)\nxmlhttp.send()\n')])])]),a("h2",{attrs:{id:"使用-ajax-的优缺点分别是什么"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#使用-ajax-的优缺点分别是什么"}},[e._v("#")]),e._v(" 使用 Ajax 的优缺点分别是什么")]),e._v(" "),a("p",[a("strong",[e._v("优点")])]),e._v(" "),a("ul",[a("li",[e._v("交互性更好。来自服务器的新内容可以动态更改，无需重新加载整个页面。")]),e._v(" "),a("li",[e._v("减少与服务器的连接，因为脚本和样式只需要被请求一次。")]),e._v(" "),a("li",[e._v("状态可以维护在一个页面上。JavaScript 变量和 DOM 状态将得到保持，因为主容器页面未被重新加载。")]),e._v(" "),a("li",[e._v("基本上包括大部分 SPA 的优点。")])]),e._v(" "),a("p",[a("strong",[e._v("缺点")])]),e._v(" "),a("ul",[a("li",[e._v("动态网页很难收藏。")]),e._v(" "),a("li",[e._v("如果 JavaScript 已在浏览器中被禁用，则不起作用。")]),e._v(" "),a("li",[e._v("有些网络爬虫不执行 JavaScript，也不会看到 JavaScript 加载的内容。")]),e._v(" "),a("li",[e._v("基本上包括大部分 SPA 的缺点。")])]),e._v(" "),a("p",[a("a",{attrs:{href:"https://github.com/yangshun/front-end-interview-handbook/blob/master/questions/javascript-questions.md",target:"_blank",rel:"noopener noreferrer"}},[e._v("https://github.com/yangshun/front-end-interview-handbook/blob/master/questions/javascript-questions.md"),a("OutboundLink")],1)]),e._v(" "),a("h2",{attrs:{id:"ajax-和-fetch-区别"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#ajax-和-fetch-区别"}},[e._v("#")]),e._v(" Ajax 和 Fetch 区别")]),e._v(" "),a("ul",[a("li",[e._v("ajax 是使用 XMLHttpRequest 对象发起的，但是用起来很麻烦，所以 ES6 新规范就有了 fetch，fetch 发一个请求不用像 ajax 那样写一大堆代码。")]),e._v(" "),a("li",[e._v("使用 fetch 无法取消一个请求，这是因为 fetch 基于 Promise，而 Promise 无法做到这一点。")]),e._v(" "),a("li",[e._v("在默认情况下，fetch 不会接受或者发送 cookies")]),e._v(" "),a("li",[e._v("fetch 没有办法原生监测请求的进度，而 XMLHttpRequest 可以")]),e._v(" "),a("li",[e._v("fetch 只对网络请求报错，对 400，500 都当做成功的请求，需要封装去处理")]),e._v(" "),a("li",[e._v("fetch 由于是 ES6 规范，兼容性上比不上 XMLHttpRequest")])]),e._v(" "),a("h2",{attrs:{id:"变量提升"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#变量提升"}},[e._v("#")]),e._v(" 变量提升")]),e._v(" "),a("p",[e._v("var 会使变量提升，这意味着变量可以在声明之前使用。let 和 const 不会使变量提升，提前使用会报错。 变量提升（hoisting）是用于解释代码中变量声明行为的术语。使用 var 关键字声明或初始化的变量，会将声明语句 “提升” 到当前作用域的顶部。 但是，只有声明才会触发提升，赋值语句（如果有的话）将保持原样。")]),e._v(" "),a("h2",{attrs:{id:"使用-let、var-和-const-创建变量有什么区别"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#使用-let、var-和-const-创建变量有什么区别"}},[e._v("#")]),e._v(" 使用 let、var 和 const 创建变量有什么区别")]),e._v(" "),a("p",[e._v("用 var 声明的变量的作用域是它当前的执行上下文，它可以是嵌套的函数，也可以是声明在任何函数外的变量。let 和 const 是块级作用域，意味着它们只能在最近的一组花括号（function、if-else 代码块或 for 循环中）中访问。")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("function foo() {\n  // 所有变量在函数中都可访问\n  var bar = 'bar';\n  let baz = 'baz';\n  const qux = 'qux';\n\n  console.log(bar); // bar\n  console.log(baz); // baz\n  console.log(qux); // qux\n}\n\nconsole.log(bar); // ReferenceError: bar is not defined\nconsole.log(baz); // ReferenceError: baz is not defined\nconsole.log(qux); // ReferenceError: qux is not defined\nif (true) {\n  var bar = 'bar';\n  let baz = 'baz';\n  const qux = 'qux';\n}\n\n// 用 var 声明的变量在函数作用域上都可访问\nconsole.log(bar); // bar\n// let 和 const 定义的变量在它们被定义的语句块之外不可访问\nconsole.log(baz); // ReferenceError: baz is not defined\nconsole.log(qux); // ReferenceError: qux is not defined\n")])])]),a("p",[e._v("var 会使变量提升，这意味着变量可以在声明之前使用。let 和 const 不会使变量提升，提前使用会报错。")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("console.log(foo); // undefined\n\nvar foo = 'foo';\n\nconsole.log(baz); // ReferenceError: can't access lexical declaration 'baz' before initialization\n\nlet baz = 'baz';\n\nconsole.log(bar); // ReferenceError: can't access lexical declaration 'bar' before initialization\n\nconst bar = 'bar';\n")])])]),a("p",[e._v("用 var 重复声明不会报错，但 let 和 const 会。")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("var foo = 'foo';\nvar foo = 'bar';\nconsole.log(foo); // \"bar\"\n\nlet baz = 'baz';\nlet baz = 'qux'; // Uncaught SyntaxError: Identifier 'baz' has already been declared\n")])])]),a("p",[e._v("let 和 const 的区别在于：let 允许多次赋值，而 const 只允许一次。")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("// 这样不会报错。\nlet foo = 'foo';\nfoo = 'bar';\n\n// 这样会报错。\nconst baz = 'baz';\nbaz = 'qux';\n")])])]),a("h2",{attrs:{id:"对象浅拷贝和深拷贝有什么区别"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#对象浅拷贝和深拷贝有什么区别"}},[e._v("#")]),e._v(" 对象浅拷贝和深拷贝有什么区别")]),e._v(" "),a("p",[e._v("在 "),a("code",[e._v("JS")]),e._v(" 中，除了基本数据类型，还存在对象、数组这种引用类型。 基本数据类型，拷贝是直接拷贝变量的值，而引用类型拷贝的其实是变量的地址。")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("let o1 = {a: 1}\nlet o2 = o1\n")])])]),a("p",[e._v("在这种情况下，如果改变 "),a("code",[e._v("o1")]),e._v(" 或 "),a("code",[e._v("o2")]),e._v(" 其中一个值的话，另一个也会变，因为它们都指向同一个地址。")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("o2.a = 3\nconsole.log(o1.a) // 3\n")])])]),a("p",[e._v("而浅拷贝和深拷贝就是在这个基础之上做的区分，如果在拷贝这个对象的时候，只对基本数据类型进行了拷贝，而对引用数据类型只是进行了引用的传递，而没有重新创建一个新的对象，则认为是浅拷贝。反之，在对引用数据类型进行拷贝的时候，创建了一个新的对象，并且复制其内的成员变量，则认为是深拷贝。")]),e._v(" "),a("h2",{attrs:{id:"怎么实现对象深拷贝"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#怎么实现对象深拷贝"}},[e._v("#")]),e._v(" 怎么实现对象深拷贝")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("let o1 = {a:{\n    b:1\n  }\n}\nlet o2 = JSON.parse(JSON.stringify(o1))\n")])])]),a("p",[e._v("另一种方法")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("function deepCopy(s) {\n    const d = {}\n    for (let k in s) {\n        if (typeof s[k] == 'object') {\n            d[k] = deepCopy(s[k])\n        } else {\n            d[k] = s[k]\n        }\n    }\n\n    return d\n}\n")])])]),a("h2",{attrs:{id:"数组去重"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#数组去重"}},[e._v("#")]),e._v(" 数组去重")]),e._v(" "),a("p",[e._v("ES5")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("function unique(arry) {\n    const temp = []\n    arry.forEach(function(item){\n        if (temp.indexOf(item) == -1) {\n            temp.push(item)\n        }\n    })\n\n    return temp\n}\n")])])]),a("p",[e._v("ES6")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("function unique(arry) {\n   return Array.from(new Set(arry))\n}\n")])])]),a("h2",{attrs:{id:"数据类型"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#数据类型"}},[e._v("#")]),e._v(" 数据类型")]),e._v(" "),a("ol",[a("li",[e._v("Undefined")]),e._v(" "),a("li",[e._v("Null")]),e._v(" "),a("li",[e._v("Boolean")]),e._v(" "),a("li",[e._v("Number")]),e._v(" "),a("li",[e._v("String")]),e._v(" "),a("li",[e._v("Object")]),e._v(" "),a("li",[e._v("symbol(ES6 新增)")])]),e._v(" "),a("h2",{attrs:{id:"内置函数-原生函数"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#内置函数-原生函数"}},[e._v("#")]),e._v(" 内置函数 (原生函数)")]),e._v(" "),a("ul",[a("li",[e._v("String")]),e._v(" "),a("li",[e._v("Number")]),e._v(" "),a("li",[e._v("Boolean")]),e._v(" "),a("li",[e._v("Object")]),e._v(" "),a("li",[e._v("Function")]),e._v(" "),a("li",[e._v("Array")]),e._v(" "),a("li",[e._v("Date")]),e._v(" "),a("li",[e._v("RegExp")]),e._v(" "),a("li",[e._v("Error")]),e._v(" "),a("li",[e._v("Symbol")])]),e._v(" "),a("p",[e._v('原始值 "I am a string" 并不是一个对象，它只是一个字面量，并且是一个不可变的值。 如果要在这个字面量上执行一些操作，比如获取长度、访问其中某个字符等，那需要将其 转换为 String 对象。 幸好，在必要时语言会自动把字符串字面量转换成一个 String 对象，也就是说你并不需要 显式创建一个对象。')]),e._v(" "),a("h2",{attrs:{id:"如何判断数组与对象"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#如何判断数组与对象"}},[e._v("#")]),e._v(" 如何判断数组与对象")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v('Array.isArray([]) // true\nArray.isArray({}) // false\n\ntypeof [] // "object"\ntypeof {} // "object"\n\nObject.prototype == [].__proto__ // false\nObject.prototype == {}.__proto__ // true\nArray.prototype == [].__proto__ // true\nArray.prototype == {}.__proto__ // false\n')])])]),a("h2",{attrs:{id:"自动分号"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#自动分号"}},[e._v("#")]),e._v(" 自动分号")]),e._v(" "),a("p",[e._v("有时 JavaScript 会自动为代码行补上缺失的分号，即自动分号插入（Automatic SemicolonInsertion，ASI）。"),a("br"),e._v("\n因为如果缺失了必要的 ; ，代码将无法运行，语言的容错性也会降低。ASI 能让我们忽略那些不必要的 ; 。"),a("br"),e._v("\n请注意，ASI 只在换行符处起作用，而不会在代码行的中间插入分号。"),a("br"),e._v("\n如果 JavaScript 解析器发现代码行可能因为缺失分号而导致错误，那么它就会自动补上分 号。并且，只有在代码行末尾与换行符之间除了空格和注释之外没有别的内容时，它才会 这样做。")]),e._v(" "),a("h2",{attrs:{id:"浮点数精度"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#浮点数精度"}},[e._v("#")]),e._v(" 浮点数精度")]),e._v(" "),a("p",[a("a",{attrs:{href:"https://www.css88.com/archives/7340",target:"_blank",rel:"noopener noreferrer"}},[e._v("https://www.css88.com/archives/7340"),a("OutboundLink")],1)]),e._v(" "),a("h2",{attrs:{id:"cookie、localstorage、sessionstorage-区别"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#cookie、localstorage、sessionstorage-区别"}},[e._v("#")]),e._v(" cookie、localStorage、sessionStorage 区别")]),e._v(" "),a("p",[e._v("| 特性 | cookie | localStorage | sessionStorage| |-|-|-|-| | 由谁初始化 | 客户端或服务器，服务器可以使用"),a("code",[e._v("Set-Cookie")]),e._v("请求头。 | 客户端 | 客户端 | | 数据的生命周期 | 一般由服务器生成，可设置失效时间，如果在浏览器生成，默认是关闭浏览器之后失效 | 永久保存，可清除 | 仅在当前会话有效，关闭页面后清除 | | 存放数据大小 | 4KB|5MB|5MB| | 与服务器通信 | 每次都会携带在 HTTP 头中，如果使用 cookie 保存过多数据会带来性能问题 | 仅在客户端保存 | 仅在客户端保存 | | 用途 | 一般由服务器生成，用于标识用户身份 | 用于浏览器缓存数据 | 用于浏览器缓存数据 | | 访问权限 | 任意窗口 | 任意窗口 | 当前页面窗口 |")]),e._v(" "),a("h2",{attrs:{id:"自执行函数-用于什么场景-好处"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#自执行函数-用于什么场景-好处"}},[e._v("#")]),e._v(" 自执行函数? 用于什么场景？好处?")]),e._v(" "),a("p",[e._v("自执行函数: 1、声明一个匿名函数 2、马上调用这个匿名函数。"),a("br"),e._v("\n作用：创建一个独立的作用域。")]),e._v(" "),a("p",[e._v("好处：防止变量弥散到全局，以免各种 js 库冲突。隔离作用域避免污染，或者截断作用域链，避免闭包造成引用变量无法释放。利用立即执行特性，返回需要的业务函数或对象，避免每次通过条件判断来处理")]),e._v(" "),a("p",[e._v("场景：一般用于框架、插件等场景")]),e._v(" "),a("h2",{attrs:{id:"多个页面之间如何进行通信"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#多个页面之间如何进行通信"}},[e._v("#")]),e._v(" 多个页面之间如何进行通信")]),e._v(" "),a("p",[e._v("有如下几个方式： "),a("em",[e._v("cookie")]),e._v(" web worker * localeStorage 和 sessionStorage")]),e._v(" "),a("h2",{attrs:{id:"css-动画和-js-动画的差异"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#css-动画和-js-动画的差异"}},[e._v("#")]),e._v(" css 动画和 js 动画的差异")]),e._v(" "),a("ol",[a("li",[e._v("代码复杂度，js 动画代码相对复杂一些")]),e._v(" "),a("li",[e._v("动画运行时，对动画的控制程度上，js 能够让动画，暂停，取消，终止，css 动画不能添加事件")]),e._v(" "),a("li",[e._v("动画性能看，js 动画多了一个 js 解析的过程，性能不如 css 动画好")])]),e._v(" "),a("p",[a("a",{attrs:{href:"https://zhuanlan.zhihu.com/p/41479807",target:"_blank",rel:"noopener noreferrer"}},[e._v("https://zhuanlan.zhihu.com/p/41479807"),a("OutboundLink")],1)]),e._v(" "),a("h2",{attrs:{id:"如何实现文件断点续传"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#如何实现文件断点续传"}},[e._v("#")]),e._v(" 如何实现文件断点续传")]),e._v(" "),a("p",[e._v("断点续传最核心的内容就是把文件 “切片” 然后再一片一片的传给服务器，但是这看似简单的上传过程却有着无数的坑。")]),e._v(" "),a("p",[e._v("首先是文件的识别，一个文件被分成了若干份之后如何告诉服务器你切了多少块，以及最终服务器应该如何把你上传上去的文件进行合并，这都是要考虑的。")]),e._v(" "),a("p",[e._v("因此在文件开始上传之前，我们和服务器要有一个 “握手” 的过程，告诉服务器文件信息，然后和服务器约定切片的大小，当和服务器达成共识之后就可以开始后续的文件传输了。")]),e._v(" "),a("p",[e._v("前台要把每一块的文件传给后台，成功之后前端和后端都要标识一下，以便后续的断点。")]),e._v(" "),a("p",[e._v("当文件传输中断之后用户再次选择文件就可以通过标识来判断文件是否已经上传了一部分，如果是的话，那么我们可以接着上次的进度继续传文件，以达到续传的功能。 有了 HTML5 的 File api 之后切割文件比想想的要简单的多的多。")]),e._v(" "),a("p",[e._v("只要用 slice 方法就可以了")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("var packet = file.slice(start, end);\n")])])]),a("p",[e._v("参数 start 是开始切片的位置，end 是切片结束的位置 单位都是字节。通过控制 start 和 end 就可以是实现文件的分块")]),e._v(" "),a("p",[e._v("如")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("file.slice(0,1000);\nfile.slice(1000,2000);\nfile.slice(2000,3000);\n// ......\n")])])]),a("p",[e._v("在把文件切成片之后，接下来要做的事情就是把这些碎片传到服务器上。 如果中间掉线了，下次再传的时候就得先从服务器获取上一次上传文件的位置，然后以这个位置开始上传接下来的文件内容。")]),e._v(" "),a("p",[a("a",{attrs:{href:"https://www.cnblogs.com/zhwl/p/3580776.html",target:"_blank",rel:"noopener noreferrer"}},[e._v("https://www.cnblogs.com/zhwl/p/3580776.html"),a("OutboundLink")],1)]),e._v(" "),a("h2",{attrs:{id:"new-一个对象经历了什么"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#new-一个对象经历了什么"}},[e._v("#")]),e._v(" new 一个对象经历了什么")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("function Test(){}\nconst test = new Test()\n")])])]),a("ol",[a("li",[e._v("创建一个新对象：")])]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("const obj = {}\n")])])]),a("ol",[a("li",[e._v("设置新对象的 constructor 属性为构造函数的名称，设置新对象的 "),a("strong",[e._v("proto")]),e._v(" 属性指向构造函数的 prototype 对象")])]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("obj.constructor = Test\nobj.__proto__ = Test.prototype\n")])])]),a("ol",[a("li",[e._v("使用新对象调用函数，函数中的 this 被指向新实例对象")])]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("Test.call(obj)\n")])])]),a("ol",[a("li",[e._v("将初始化完毕的新对象地址，保存到等号左边的变量中")])]),e._v(" "),a("h2",{attrs:{id:"bind、call、apply-的区别"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#bind、call、apply-的区别"}},[e._v("#")]),e._v(" bind、call、apply 的区别")]),e._v(" "),a("p",[e._v("call 和 apply 其实是一样的，区别就在于传参时参数是一个一个传或者是以一个数组的方式来传。"),a("br"),e._v("\ncall 和 apply 都是在调用时生效，改变调用者的 this 指向。")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("let name = 'Jack'\nconst obj = {name: 'Tom'}\nfunction sayHi() {console.log('Hi! ' + this.name)}\n\nsayHi() // Hi! Jack\nsayHi.call(obj) // Hi! Tom\n")])])]),a("p",[e._v("bind 也是改变 this 指向，不过不是在调用时生效，而是返回一个新函数。")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("const newFunc = sayHi.bind(obj)\nnewFunc() // Hi! Tom\n")])])]),a("h2",{attrs:{id:"请简述javascript中的this。"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#请简述javascript中的this。"}},[e._v("#")]),e._v(" 请简述"),a("code",[e._v("JavaScript")]),e._v("中的"),a("code",[e._v("this")]),e._v("。")]),e._v(" "),a("p",[e._v("JS 中的"),a("code",[e._v("this")]),e._v("是一个相对复杂的概念，不是简单几句能解释清楚的。粗略地讲，函数的调用方式决定了"),a("code",[e._v("this")]),e._v("的值。我阅读了网上很多关于"),a("code",[e._v("this")]),e._v("的文章，"),a("a",{attrs:{href:"https://medium.com/@arnav_aggarwal",target:"_blank",rel:"noopener noreferrer"}},[e._v("Arnav Aggrawal"),a("OutboundLink")],1),e._v(" 写的比较清楚。"),a("code",[e._v("this")]),e._v("取值符合以下规则：")]),e._v(" "),a("ol",[a("li",[e._v("在调用函数时使用"),a("code",[e._v("new")]),e._v("关键字，函数内的"),a("code",[e._v("this")]),e._v("是一个全新的对象。")]),e._v(" "),a("li",[e._v("如果"),a("code",[e._v("apply")]),e._v("、"),a("code",[e._v("call")]),e._v("或"),a("code",[e._v("bind")]),e._v("方法用于调用、创建一个函数，函数内的 this 就是作为参数传入这些方法的对象。")]),e._v(" "),a("li",[e._v("当函数作为对象里的方法被调用时，函数内的"),a("code",[e._v("this")]),e._v("是调用该函数的对象。比如当"),a("code",[e._v("obj.method()")]),e._v("被调用时，函数内的 this 将绑定到"),a("code",[e._v("obj")]),e._v("对象。")]),e._v(" "),a("li",[e._v("如果调用函数不符合上述规则，那么"),a("code",[e._v("this")]),e._v("的值指向全局对象（global object）。浏览器环境下"),a("code",[e._v("this")]),e._v("的值指向"),a("code",[e._v("window")]),e._v("对象，但是在严格模式下 ("),a("code",[e._v("'use strict'")]),e._v(")，"),a("code",[e._v("this")]),e._v("的值为"),a("code",[e._v("undefined")]),e._v("。")]),e._v(" "),a("li",[e._v("如果符合上述多个规则，则较高的规则（1 号最高，4 号最低）将决定"),a("code",[e._v("this")]),e._v("的值。")]),e._v(" "),a("li",[e._v("如果该函数是 ES2015 中的箭头函数，将忽略上面的所有规则，"),a("code",[e._v("this")]),e._v("被设置为它被创建时的上下文。")])]),e._v(" "),a("p",[e._v("想获得更深入的解释，请查看"),a("a",{attrs:{href:"https://codeburst.io/the-simple-rules-to-this-in-javascript-35d97f31bde3",target:"_blank",rel:"noopener noreferrer"}},[e._v("他在 Medium 上的文章"),a("OutboundLink")],1),e._v("。")]),e._v(" "),a("p",[a("a",{attrs:{href:"https://github.com/yangshun/front-end-interview-handbook/blob/master/Translations/Chinese/questions/javascript-questions.md#%E8%AF%B7%E7%AE%80%E8%BF%B0javascript%E4%B8%AD%E7%9A%84this",target:"_blank",rel:"noopener noreferrer"}},[e._v("https://github.com/yangshun/front-end-interview-handbook/blob/master/Translations/Chinese/questions/javascript-questions.md#%E8%AF%B7%E7%AE%80%E8%BF%B0javascript%E4%B8%AD%E7%9A%84this"),a("OutboundLink")],1)]),e._v(" "),a("h2",{attrs:{id:"如何确定-this-指向"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#如何确定-this-指向"}},[e._v("#")]),e._v(" 如何确定 this 指向")]),e._v(" "),a("p",[e._v("如果要判断一个运行中函数的 this 绑定，就需要找到这个函数的直接调用位置。找到之后就可以顺序应用下面这四条规则来判断 this 的绑定对象。 1. 由 new 调用？绑定到新创建的对象。 2. 由 call 或者 apply （或者 bind ）调用？绑定到指定的对象。 3. 由上下文对象调用？绑定到那个上下文对象。 4. 默认：在严格模式下绑定到 undefined ，否则绑定到全局对象。")]),e._v(" "),a("p",[e._v("一定要注意，有些调用可能在无意中使用默认绑定规则。如果想 “更安全” 地忽略 this 绑定，你可以使用一个 DMZ 对象，比如 ø = Object.create(null) ，以保护全局对象。"),a("br"),e._v("\nES6 中的箭头函数并不会使用四条标准的绑定规则，而是根据当前的词法作用域来决定 this ，具体来说，箭头函数会继承外层函数调用的 this 绑定（无论 this 绑定到什么）。这其实和 ES6 之前代码中的 self = this 机制一样")]),e._v(" "),a("p",[e._v("参考：《你不知道的 JavaScript》")]),e._v(" "),a("h2",{attrs:{id:"和-的区别是什么"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#和-的区别是什么"}},[e._v("#")]),e._v(" == 和 === 的区别是什么")]),e._v(" "),a("p",[a("code",[e._v("==")]),e._v("是抽象相等运算符，而"),a("code",[e._v("===")]),e._v("是严格相等运算符。"),a("code",[e._v("==")]),e._v("运算符是在进行必要的类型转换后，再比较。"),a("code",[e._v("===")]),e._v("运算符不会进行类型转换，所以如果两个值不是相同的类型，会直接返回"),a("code",[e._v("false")]),e._v("。使用"),a("code",[e._v("==")]),e._v("时，可能发生一些特别的事情，例如：")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("1 == '1'; // true\n1 == [1]; // true\n1 == true; // true\n0 == ''; // true\n0 == '0'; // true\n0 == false; // true\n")])])]),a("p",[e._v("如果你对"),a("code",[e._v("==")]),e._v("和"),a("code",[e._v("===")]),e._v("的概念不是特别了解，建议大多数情况下使用"),a("code",[e._v("===")])]),e._v(" "),a("h2",{attrs:{id:"箭头函数和普通函数有什么区别"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#箭头函数和普通函数有什么区别"}},[e._v("#")]),e._v(" 箭头函数和普通函数有什么区别")]),e._v(" "),a("ul",[a("li",[e._v("函数体内的"),a("code",[e._v("this")]),e._v("对象，就是定义时所在的对象，而不是使用时所在的对象，用"),a("code",[e._v("call")]),e._v(" "),a("code",[e._v("apply")]),e._v(" "),a("code",[e._v("bind")]),e._v("也不能改变"),a("code",[e._v("this")]),e._v("指向")]),e._v(" "),a("li",[e._v("不可以当作构造函数，也就是说，不可以使用"),a("code",[e._v("new")]),e._v("命令，否则会抛出一个错误。")]),e._v(" "),a("li",[e._v("不可以使用"),a("code",[e._v("arguments")]),e._v("对象，该对象在函数体内不存在。如果要用，可以用 "),a("code",[e._v("rest")]),e._v(" 参数代替。")]),e._v(" "),a("li",[e._v("不可以使用"),a("code",[e._v("yield")]),e._v("命令，因此箭头函数不能用作 "),a("code",[e._v("Generator")]),e._v(" 函数。")]),e._v(" "),a("li",[e._v("箭头函数没有原型对象"),a("code",[e._v("prototype")])])]),e._v(" "),a("h2",{attrs:{id:"白屏时间"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#白屏时间"}},[e._v("#")]),e._v(" 白屏时间")]),e._v(" "),a("p",[e._v("白屏时间是指浏览器从输入网址，到浏览器开始显示内容的时间。")]),e._v(" "),a("p",[e._v("Performance 接口可以获取到当前页面中与性能相关的信息, 该类型的对象可以通过调用只读属性 Window.performance 来获得。")]),e._v(" "),a("p",[e._v("performance.timing.navigationStart: PerformanceTiming.navigationStart 是一个返回代表一个时刻的 unsigned long long 型只读属性，为紧接着在相同的浏览环境下卸载前一个文档结束之时的 Unix 毫秒时间戳。如果没有上一个文档，则它的值相当于 PerformanceTiming.fetchStart。")]),e._v(" "),a("p",[e._v("所以将以下脚本放在 "),a("code",[e._v("</head>")]),e._v(" 前面就能获取白屏时间。")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("<script>\n\tnew Date() - performance.timing.navigationStart\n<\/script>\n")])])]),a("h2",{attrs:{id:"当你在浏览器输入一个地址后发生了什么"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#当你在浏览器输入一个地址后发生了什么"}},[e._v("#")]),e._v(" 当你在浏览器输入一个地址后发生了什么")]),e._v(" "),a("p",[a("a",{attrs:{href:"https://github.com/skyline75489/what-happens-when-zh_CN/blob/master/README.rst?utm_medium=social&utm_source=wechat_session&from=timeline&isappinstalled=0",target:"_blank",rel:"noopener noreferrer"}},[e._v("https://github.com/skyline75489/what-happens-when-zh_CN/blob/master/README.rst?utm_medium=social&utm_source=wechat_session&from=timeline&isappinstalled=0"),a("OutboundLink")],1)]),e._v(" "),a("h2",{attrs:{id:"页面大量图片-如何优化加载-优化用户体验"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#页面大量图片-如何优化加载-优化用户体验"}},[e._v("#")]),e._v(" 页面大量图片，如何优化加载，优化用户体验")]),e._v(" "),a("ol",[a("li",[e._v("图片懒加载。在页面的未可视区域添加一个滚动事件，判断图片位置与浏览器顶端的距离与页面的距离，如果前者小于后者，优先加载。")]),e._v(" "),a("li",[e._v("如果为幻灯片、相册等，可以使用图片预加载技术，将当前展示图片的前一张和后一张优先下载。")]),e._v(" "),a("li",[e._v("如果图片为 css 图片，可以使用 CSSsprite，SVGsprite 等技术。")]),e._v(" "),a("li",[e._v("如果图片过大，可以使用特殊编码的图片，加载时会先加载一张压缩的特别厉害的缩略图，以提高用户体验。")]),e._v(" "),a("li",[e._v("如果图片展示区域小于图片的真实大小，应在服务器端根据业务需要先进行图片压缩，图片压缩后大小与展示一致。")])]),e._v(" "),a("p",[a("a",{attrs:{href:"https://www.jianshu.com/p/5d82bba9e1a1",target:"_blank",rel:"noopener noreferrer"}},[e._v("https://www.jianshu.com/p/5d82bba9e1a1"),a("OutboundLink")],1)]),e._v(" "),a("h2",{attrs:{id:"js-网络请求性能优化之防抖与节流"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#js-网络请求性能优化之防抖与节流"}},[e._v("#")]),e._v(" js 网络请求性能优化之防抖与节流")]),e._v(" "),a("ul",[a("li",[a("p",[e._v("防抖 (debounce)"),a("br"),e._v("\n在函数需要频繁触发时，只有当有足够空闲的时间时，才执行一次。就好像在百度搜索时，每次输入之后都有联想词弹出，这个控制联想词的方法就不可能是输入框内容一改变就触发的，他一定是当你结束输入一段时间之后才会触发。")])]),e._v(" "),a("li",[a("p",[e._v("节流 (thorttle)"),a("br"),e._v("\n预定一个函数只有在大于等于执行周期时才执行，周期内调用不执行。就好像你在淘宝抢购某一件限量热卖商品时，你不断点刷新点购买，可是总有一段时间你点上是没有效果，这里就用到了节流，就是怕点的太快导致系统出现 bug。")])]),e._v(" "),a("li",[a("p",[e._v("区别"),a("br"),e._v("\n在发生持续触发事件时，防抖设置事件延迟并在空闲时间去触发事件，而节流则是隔一定的时间触发一次。")])])]),e._v(" "),a("p",[e._v("具体请看："),a("br"),e._v(" "),a("a",{attrs:{href:"https://blog.csdn.net/jacoox/article/details/80719456",target:"_blank",rel:"noopener noreferrer"}},[e._v("https://blog.csdn.net/jacoox/article/details/80719456"),a("OutboundLink")],1)]),e._v(" "),a("h2",{attrs:{id:"如何做到修改-url-参数页面不刷新"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#如何做到修改-url-参数页面不刷新"}},[e._v("#")]),e._v(" 如何做到修改 url 参数页面不刷新")]),e._v(" "),a("p",[e._v("HTML5 引入了 "),a("code",[e._v("history.pushState()")]),e._v(" 和 "),a("code",[e._v("history.replaceState()")]),e._v(" 方法，它们分别可以添加和修改历史记录条目。")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v('let stateObj = {\n    foo: "bar",\n};\n\nhistory.pushState(stateObj, "page 2", "bar.html");\n')])])]),a("p",[e._v("假设当前页面为 "),a("code",[e._v("foo.html")]),e._v("，执行上述代码后会变为 "),a("code",[e._v("bar.html")]),e._v("，点击浏览器后退，会变为 "),a("code",[e._v("foo.html")]),e._v("，但浏览器并不会刷新。 "),a("code",[e._v("pushState()")]),e._v(" 需要三个参数: 一个状态对象, 一个标题 (目前被忽略), 和 (可选的) 一个 URL. 让我们来解释下这三个参数详细内容：")]),e._v(" "),a("ul",[a("li",[a("p",[e._v("状态对象 — 状态对象 "),a("code",[e._v("state")]),e._v(" 是一个 JavaScript 对象，通过 "),a("code",[e._v("pushState ()")]),e._v(" 创建新的历史记录条目。无论什么时候用户导航到新的状态，"),a("code",[e._v("popstate")]),e._v(" 事件就会被触发，且该事件的 "),a("code",[e._v("state")]),e._v(" 属性包含该历史记录条目状态对象的副本。 状态对象可以是能被序列化的任何东西。原因在于 Firefox 将状态对象保存在用户的磁盘上，以便在用户重启浏览器时使用，我们规定了状态对象在序列化表示后有 640k 的大小限制。如果你给 "),a("code",[e._v("pushState()")]),e._v(" 方法传了一个序列化后大于 640k 的状态对象，该方法会抛出异常。如果你需要更大的空间，建议使用 "),a("code",[e._v("sessionStorage")]),e._v(" 以及 "),a("code",[e._v("localStorage")]),e._v(".")])]),e._v(" "),a("li",[a("p",[e._v("标题 — Firefox 目前忽略这个参数，但未来可能会用到。传递一个空字符串在这里是安全的，而在将来这是不安全的。二选一的话，你可以为跳转的 "),a("code",[e._v("state")]),e._v(" 传递一个短标题。")])]),e._v(" "),a("li",[a("p",[e._v("URL — 该参数定义了新的历史 URL 记录。注意，调用 "),a("code",[e._v("pushState()")]),e._v(" 后浏览器并不会立即加载这个 URL，但可能会在稍后某些情况下加载这个 URL，比如在用户重新打开浏览器时。新 URL 不必须为绝对路径。如果新 URL 是相对路径，那么它将被作为相对于当前 URL 处理。新 URL 必须与当前 URL 同源，否则 "),a("code",[e._v("pushState()")]),e._v(" 会抛出一个异常。该参数是可选的，缺省为当前 URL。")])])]),e._v(" "),a("h2",{attrs:{id:"格式化金钱-每千分位加逗号"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#格式化金钱-每千分位加逗号"}},[e._v("#")]),e._v(" 格式化金钱，每千分位加逗号")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("function format(str) {\n    let s = ''\n    let count = 0\n    for (let i = str.length - 1; i >= 0; i--) {\n        s = str[i] + s\n        count++\n        if (count % 3 == 0 && i != 0) {\n            s = ',' + s\n        }\n    }\n    return s\n}\nfunction format(str) {\n    return str.replace(/(\\d)(?=(?:\\d{3})+$)/g, '$1,')\n}\n")])])]),a("h2",{attrs:{id:"请用-js-去除字符串空格"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#请用-js-去除字符串空格"}},[e._v("#")]),e._v(" 请用 js 去除字符串空格")]),e._v(" "),a("h3",{attrs:{id:"去除所有空格"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#去除所有空格"}},[e._v("#")]),e._v(" 去除所有空格")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("str.replace(/\\s/g, '')\n")])])]),a("h3",{attrs:{id:"去除两边空格"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#去除两边空格"}},[e._v("#")]),e._v(" 去除两边空格")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("str.replace(/^\\s+|\\s+$/g, '')\n// 原生方法\nstr.trim()\n")])])]),a("h2",{attrs:{id:"http-问题"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#http-问题"}},[e._v("#")]),e._v(" HTTP 问题")]),e._v(" "),a("h2",{attrs:{id:"restful"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#restful"}},[e._v("#")]),e._v(" RESTful")]),e._v(" "),a("p",[e._v("REST 指的是一组架构约束条件和原则。满足这些约束条件和原则的应用程序或设计就是 RESTful。")]),e._v(" "),a("ul",[a("li",[e._v("GET"),a("br"),e._v("\nget 方法在 Rest 中主要用于获取资源，能够发送参数，不过有限制，且参数都会以? 开头的形 式附加在 URL 尾部。 规范的 get 方法处理器应该是幂等的，也就是说对一个资源不论发送多少次 get 请求都不会更改数据或造成破坏。")]),e._v(" "),a("li",[e._v("POST"),a("br"),e._v("\npost 方法在 Rest 请求中主要用于添加资源，参数信息存放在请求报文的消息体中相对安全，且可发送较大信息")]),e._v(" "),a("li",[e._v("PUT"),a("br"),e._v("\nput 方法在 Rest 中主要用于更新资源，因为大多数浏览器不支持 put 和 delete，会自动将 put 和 delete 请求转化为 get 和 post. 因此为了使用 put 和 delete 方法, 需要以 post 发送请求，在表单中使用隐藏域发送真正的请求。 put 方法的参数是同 post 一样是存放在消息中的，同样具有安全性，可发送较大信息。 put 方法是幂等的，对同一 URL 资源做出的同一数据的任意次 put 请求其对数据的改变都是一致的。")]),e._v(" "),a("li",[e._v("DELETE"),a("br"),e._v("\nDelete 在 Rest 请求中主要用于删除资源，因为大多数浏览器不支持 put 和 delete，会自动将 put 和 delete 请求转化为 get 和 post。 因此为了使用 put 和 delete 方法, 需要以 post 发送请求，在表单中使用隐藏域发送真正的请求。 Delete 方法的参数同 post 一样存放在消息体中, 具有安全性，可发送较大信息 Delete 方法是幂等的，不论对同一个资源进行多少次 delete 请求都不会破坏数据")])]),e._v(" "),a("p",[a("a",{attrs:{href:"https://blog.csdn.net/jnshu_it/article/details/80203696",target:"_blank",rel:"noopener noreferrer"}},[e._v("https://blog.csdn.net/jnshu_it/article/details/80203696"),a("OutboundLink")],1)]),e._v(" "),a("h2",{attrs:{id:"get-和-post-的区别"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#get-和-post-的区别"}},[e._v("#")]),e._v(" GET 和 POST 的区别")]),e._v(" "),a("ul",[a("li",[e._v("GET 产生一个 TCP 数据包；POST 产生两个 TCP 数据包。")]),e._v(" "),a("li",[e._v("GET 在浏览器回退时是无害的，而 POST 会再次提交请求。")]),e._v(" "),a("li",[e._v("GET 产生的 URL 地址可以被 Bookmark，而 POST 不可以。")]),e._v(" "),a("li",[e._v("GET 请求会被浏览器主动 cache，而 POST 不会，除非手动设置。")]),e._v(" "),a("li",[e._v("GET 请求只能进行 url 编码，而 POST 支持多种编码方式。")]),e._v(" "),a("li",[e._v("GET 请求参数会被完整保留在浏览器历史记录里，而 POST 中的参数不会被保留。")]),e._v(" "),a("li",[e._v("GET 请求在 URL 中传送的参数是有长度限制的，而 POST 么有。")]),e._v(" "),a("li",[e._v("对参数的数据类型，GET 只接受 ASCII 字符，而 POST 没有限制。")]),e._v(" "),a("li",[e._v("GET 比 POST 更不安全，因为参数直接暴露在 URL 上，所以不能用来传递敏感信息。")]),e._v(" "),a("li",[e._v("GET 参数通过 URL 传递，POST 放在 Request body 中。")])]),e._v(" "),a("h2",{attrs:{id:"accept-和-content-type"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#accept-和-content-type"}},[e._v("#")]),e._v(" Accept 和 Content-Type")]),e._v(" "),a("p",[e._v("Accept 请求头用来告知客户端可以处理的内容类型，这种内容类型用 MIME 类型来表示。 服务器使用 Content-Type 应答头通知客户端它的选择。")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("Accept: text/html\nAccept: image/*\nAccept: text/html, application/xhtml+xml, application/xml;q=0.9, */*;q=0.8\n")])])]),a("p",[e._v("1.Accept 属于请求头， Content-Type 属于实体头。"),a("br"),e._v("\nHttp 报头分为通用报头，请求报头，响应报头和实体报头。"),a("br"),e._v("\n请求方的 http 报头结构：通用报头 | 请求报头 | 实体报头"),a("br"),e._v("\n响应方的 http 报头结构：通用报头 | 响应报头 | 实体报头")]),e._v(" "),a("p",[e._v("2.Accept 代表发送端（客户端）希望接受的数据类型。"),a("br"),e._v("\n比如：Accept：text/xml;"),a("br"),e._v("\n代表客户端希望接受的数据类型是 xml 类型")]),e._v(" "),a("p",[e._v("Content-Type 代表发送端（客户端 | 服务器）发送的实体数据的数据类型。"),a("br"),e._v("\n比如：Content-Type：text/html;"),a("br"),e._v("\n代表发送端发送的数据格式是 html。")]),e._v(" "),a("p",[e._v("二者合起来，"),a("br"),e._v("\nAccept:text/xml；"),a("br"),e._v("\nContent-Type:text/html"),a("br"),e._v("\n即代表希望接受的数据类型是 xml 格式，本次请求发送的数据的数据格式是 html。")]),e._v(" "),a("h2",{attrs:{id:"状态码"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#状态码"}},[e._v("#")]),e._v(" 状态码")]),e._v(" "),a("p",[e._v("| 状态码 | 类别 | 描述 | | -- | -- | -- | | 1xx | Informational（信息状态码） | 接受请求正在处理 | | 2xx | Success（成功状态码） | 请求正常处理完毕 | | 3xx | Redirection（重定向状态码） | 需要附加操作已完成请求 | | 4xx | Client Error（客户端错误状态码） | 服务器无法处理请求 | | 5xx | Server Error（服务器错误状态码） | 服务器处理请求出错 |")]),e._v(" "),a("h2",{attrs:{id:"http-缓存"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#http-缓存"}},[e._v("#")]),e._v(" HTTP 缓存")]),e._v(" "),a("p",[a("a",{attrs:{href:"https://segmentfault.com/a/1190000010690320",target:"_blank",rel:"noopener noreferrer"}},[e._v("https://segmentfault.com/a/1190000010690320"),a("OutboundLink")],1)]),e._v(" "),a("h2",{attrs:{id:"如何处理不让别人盗用你的图片-访问你的服务器资源"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#如何处理不让别人盗用你的图片-访问你的服务器资源"}},[e._v("#")]),e._v(" 如何处理不让别人盗用你的图片，访问你的服务器资源")]),e._v(" "),a("ul",[a("li",[e._v("http header, 对 refer 做判断看来源是不是自己的网站，如果不是就拒绝")]),e._v(" "),a("li",[e._v("通过 session 校验，如果不通过特定服务生成 cookie 和 session 就不能请求得到资源")])]),e._v(" "),a("h2",{attrs:{id:"http-与-https-的区别"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#http-与-https-的区别"}},[e._v("#")]),e._v(" Http 与 Https 的区别")]),e._v(" "),a("ul",[a("li",[e._v("HTTP 的 URL 以 http:// 开头，而 HTTPS 的 URL 以 https:// 开头")]),e._v(" "),a("li",[e._v("HTTP 是不安全的，而 HTTPS 是安全的")]),e._v(" "),a("li",[e._v("HTTP 标准端口是 80 ，而 HTTPS 的标准端口是 443")]),e._v(" "),a("li",[e._v("在 OSI 网络模型中，HTTP 工作于应用层，而 HTTPS 的安全传输机制工作在传输层")]),e._v(" "),a("li",[e._v("HTTP 无法加密，而 HTTPS 对传输的数据进行加密")]),e._v(" "),a("li",[e._v("HTTP 无需证书，而 HTTPS 需要 CA 机构 wosign 的颁发的 SSL 证书")])]),e._v(" "),a("p",[a("a",{attrs:{href:"https://zhuanlan.zhihu.com/p/33778904",target:"_blank",rel:"noopener noreferrer"}},[e._v("https://zhuanlan.zhihu.com/p/33778904"),a("OutboundLink")],1)]),e._v(" "),a("h2",{attrs:{id:"什么是-http-协议无状态协议-怎么解决-http-协议无状态协议"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#什么是-http-协议无状态协议-怎么解决-http-协议无状态协议"}},[e._v("#")]),e._v(" 什么是 Http 协议无状态协议? 怎么解决 Http 协议无状态协议?")]),e._v(" "),a("p",[e._v("无状态协议对于事务处理没有记忆能力。缺少状态意味着如果后续处理需要前面的信息也就是说，"),a("br"),e._v("\n当客户端一次 HTTP 请求完成以后，客户端再发送一次 HTTP 请求，HTTP 并不知道当前客户端是一个” 老用户 “。")]),e._v(" "),a("p",[e._v("可以使用 Cookie 来解决无状态的问题，Cookie 就相当于一个通行证，第一次访问的时候给客户端发送一个 Cookie，"),a("br"),e._v("\n当客户端再次来的时候，拿着 Cookie(通行证)，那么服务器就知道这个是” 老用户 “。")]),e._v(" "),a("p",[a("a",{attrs:{href:"https://zhuanlan.zhihu.com/p/33778904",target:"_blank",rel:"noopener noreferrer"}},[e._v("https://zhuanlan.zhihu.com/p/33778904"),a("OutboundLink")],1)]),e._v(" "),a("h2",{attrs:{id:"常用的-http-方法有哪些"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#常用的-http-方法有哪些"}},[e._v("#")]),e._v(" 常用的 HTTP 方法有哪些")]),e._v(" "),a("ul",[a("li",[e._v("GET：用于请求访问已经被 URL（统一资源标识符）识别的资源，可以通过 URL 传参给服务器。")]),e._v(" "),a("li",[e._v("POST：用于传输信息给服务器，主要功能与 Get 方法类似，但一般推荐 POST 方式。")]),e._v(" "),a("li",[e._v("PUT：传输文件，报文主体包含文件内容，保存到对应 URL 位置。")]),e._v(" "),a("li",[e._v("HEAD：获取报文首部，与 GET 方法类似，只是不返回报文主体，一般用于验证 URL 是否有效。")]),e._v(" "),a("li",[e._v("DELET：删除文件，与 PUT 方法相反，删除对应 URL 位置的文件。OPTIONS：查询相应 URL 支持的 HTTP 方法。")])]),e._v(" "),a("h2",{attrs:{id:"一次完整的-http-请求所经历的-7-个步骤"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#一次完整的-http-请求所经历的-7-个步骤"}},[e._v("#")]),e._v(" 一次完整的 HTTP 请求所经历的 7 个步骤")]),e._v(" "),a("p",[e._v("HTTP 通信机制是在一次完整的 HTTP 通信过程中，Web 浏览器与 Web 服务器之间将完成下列 7 个步骤：")]),e._v(" "),a("ul",[a("li",[e._v("建立 TCP 连接")])]),e._v(" "),a("p",[e._v("在 HTTP 工作开始之前，Web 浏览器首先要通过网络与 Web 服务器建立连接，该连接是通过 TCP 来完成的，该协议与 IP 协议共同构建 Internet，即著名的 TCP/IP 协议族，因此 Internet 又被称作是 TCP/IP 网络。HTTP 是比 TCP 更高层次的应用层协议，根据规则， 只有低层协议建立之后才能，才能进行更层协议的连接，因此，首先要建立 TCP 连接，一般 TCP 连接的端口号是 80。")]),e._v(" "),a("ul",[a("li",[e._v("Web 浏览器向 Web 服务器发送请求行")])]),e._v(" "),a("p",[e._v("一旦建立了 TCP 连接，Web 浏览器就会向 Web 服务器发送请求命令。例如：GET /sample/hello.jsp HTTP/1.1。")]),e._v(" "),a("ul",[a("li",[e._v("Web 浏览器发送请求头")])]),e._v(" "),a("p",[e._v("浏览器发送其请求命令之后，还要以头信息的形式向 Web 服务器发送一些别的信息，之后浏览器发送了一空白行来通知服务器，它已经结束了该头信息的发送。")]),e._v(" "),a("ul",[a("li",[e._v("Web 服务器应答")])]),e._v(" "),a("p",[e._v("客户机向服务器发出请求后，服务器会客户机回送应答， HTTP/1.1 200 OK ，应答的第一部分是协议的版本号和应答状态码。")]),e._v(" "),a("ul",[a("li",[e._v("Web 服务器发送应答头")])]),e._v(" "),a("p",[e._v("正如客户端会随同请求发送关于自身的信息一样，服务器也会随同应答向用户发送关于它自己的数据及被请求的文档。")]),e._v(" "),a("ul",[a("li",[e._v("Web 服务器向浏览器发送数据")])]),e._v(" "),a("p",[e._v("Web 服务器向浏览器发送头信息后，它会发送一个空白行来表示头信息的发送到此为结束，接着，它就以 Content-Type 应答头信息所描述的格式发送用户所请求的实际数据。")]),e._v(" "),a("ul",[a("li",[e._v("Web 服务器关闭 TCP 连接")])]),e._v(" "),a("p",[e._v("一般情况下，一旦 Web 服务器向浏览器发送了请求数据，它就要关闭 TCP 连接，然后如果浏览器或者服务器在其头信息加入了这行代码：")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("Connection:keep-alive\n")])])]),a("p",[e._v("TCP 连接在发送后将仍然保持打开状态，于是，浏览器可以继续通过相同的连接发送请求。保持连接节省了为每个请求建立新连接所需的时间，还节约了网络带宽。")]),e._v(" "),a("p",[e._v("建立 TCP 连接 -> 发送请求行 -> 发送请求头 ->（到达服务器）发送状态行 -> 发送响应头 -> 发送响应数据 -> 断 TCP 连接")]),e._v(" "),a("p",[a("a",{attrs:{href:"https://juejin.im/post/5a8102e0f265da4e710f5910",target:"_blank",rel:"noopener noreferrer"}},[e._v("https://juejin.im/post/5a8102e0f265da4e710f5910"),a("OutboundLink")],1)]),e._v(" "),a("h2",{attrs:{id:"vue-问题"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#vue-问题"}},[e._v("#")]),e._v(" Vue 问题")]),e._v(" "),a("h2",{attrs:{id:"什么是-mvvm"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#什么是-mvvm"}},[e._v("#")]),e._v(" 什么是 mvvm")]),e._v(" "),a("p",[e._v("MVVM 最早由微软提出来，它借鉴了桌面应用程序的 MVC 思想，在前端页面中，把 Model 用纯 JavaScript 对象表示，View 负责显示，两者做到了最大限度的分离 把 Model 和 View 关联起来的就是 ViewModel。"),a("br"),e._v("\nViewModel 负责把 Model 的数据同步到 View 显示出来，还负责把 View 的修改同步回 Model"),a("br"),e._v("\nView 和 Model 之间的同步工作完全是自动的，无需人为干涉（由 viewModel 完成，在这里指 VUE）"),a("br"),e._v("\n因此开发者只需关注业务逻辑，不需要手动操作 DOM, 不需要关注数据状态的同步问题，复杂的数据状态维护完全由 MVVM 来统一管理")]),e._v(" "),a("h3",{attrs:{id:"viewmodel-如何编写"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#viewmodel-如何编写"}},[e._v("#")]),e._v(" ViewModel 如何编写？")]),e._v(" "),a("p",[e._v("需要用 JavaScript 编写一个通用的 ViewModel，这样，就可以复用整个 MVVM 模型了")]),e._v(" "),a("p",[e._v("一个 MVVM 框架和 jQuery 操作 DOM 相比有什么区别？ 我们先看用 jQuery 实现的修改两个 DOM 节点的例子：")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("\x3c!-- HTML --\x3e\n<p>Hello, <span>Bart</span>!</p>\n<p>You are <span>12</span>.</p>\n\nHello, Bart!\n\nYou are 12.\n")])])]),a("p",[e._v("用 jQuery 修改 name 和 age 节点的内容：")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("var name = 'Homer';\nvar age = 51;\n\n$('#name').text(name);\n$('#age').text(age);\n")])])]),a("p",[e._v("如果我们使用 MVVM 框架来实现同样的功能，我们首先并不关心 DOM 的结构，而是关心数据如何存储。最简单的数据存储方式是使用 JavaScript 对象：")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("var person = {\n    name: 'Bart',\n    age: 12\n}\n")])])]),a("p",[e._v("我们把变量 person 看作 Model，把 HTML 某些 DOM 节点看作 View，并假定它们之间被关联起来了。")]),e._v(" "),a("p",[e._v("要把显示的 name 从 Bart 改为 Homer，把显示的 age 从 12 改为 51，我们并不操作 DOM，而是直接修改 JavaScript 对象：")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("person.name = 'Homer';\nperson.age = 51;\n")])])]),a("p",[e._v("执行上面的代码，我们惊讶地发现，改变 JavaScript 对象的状态，会导致 DOM 结构作出对应的变化！这让我们的关注点从如何操作 DOM 变成了如何更新 JavaScript 对象的状态，而操作 JavaScript 对象比 DOM 简单多了！")]),e._v(" "),a("p",[e._v("这就是 MVVM 的设计思想：关注 Model 的变化，让 MVVM 框架去自动更新 DOM 的状态，从而把开发者从操作 DOM 的繁琐步骤中解脱出来！ 下图可以很好的解释 view viewModel model 之间的关系")]),e._v(" "),a("p",[a("img",{attrs:{src:"https://pic2.zhimg.com/v2-788d450307c6a2b59be51285848dce91_b.jpg",alt:""}}),a("img",{attrs:{src:"https://pic2.zhimg.com/v2-788d450307c6a2b59be51285848dce91_r.jpg",alt:""}})]),e._v(" "),a("h2",{attrs:{id:"vue-的优点是什么"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#vue-的优点是什么"}},[e._v("#")]),e._v(" Vue 的优点是什么")]),e._v(" "),a("p",[e._v("mvvm 的优点即是 vue 的优点，在这里再总结一下："),a("br"),e._v("\n数据和视频之间的同步工作完全是自动的，无需人为干涉，所以开发者只需关注业务逻辑，不需要手动操作 DOM, 不需要关注数据状态的同步问题， 复杂的数据状态维护完全由 MVVM 来统一管理，节省了很多精力。")]),e._v(" "),a("h2",{attrs:{id:"对于生命周期的理解"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#对于生命周期的理解"}},[e._v("#")]),e._v(" 对于生命周期的理解")]),e._v(" "),a("p",[e._v("创建一个 Vue 实例，是一个漫长的过程，要经历初始化，数据合并，模板解析，数据渲染等等一系列过程。 所以，为了能实现在这个过程里面插入自己想要提前做的事情，就有了生命周期钩子函数。")]),e._v(" "),a("h3",{attrs:{id:"举个例子"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#举个例子"}},[e._v("#")]),e._v(" 举个例子：")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("一辆公交车，从出发点A站到终点站B，中间有很多站点，公交车每到一个站点，就得停下来，\n等待客人上车，然后再驶往下一个站点，一直到终点站为止。\nA和B之间的站点，就像是这个路程的生命周期。每一个站点都是一个不同的生命周期（站点名不同），\n只要到了站点，就得执行该站点对应的生命周期函数，\n只不过每个站点的生命周期函数都是一样的（等待客人上车）。\n")])])]),a("p",[e._v("Vue 中的生命周期也是一样，对应了 Vue 实例从创建到结束之间的每一个过程。 例如，Vue 的"),a("code",[e._v("beforeCreate")]),e._v("周期，指的就是 Vue 在实例初始化之后，数据观测 (data observer) 和 event/watcher 事件配置之前被调用。")]),e._v(" "),a("p",[e._v("至于 Vue 具体的生命周期函数有哪些，请看官网 "),a("a",{attrs:{href:"https://cn.vuejs.org/v2/api/#%E9%80%89%E9%A1%B9-%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E9%92%A9%E5%AD%90",target:"_blank",rel:"noopener noreferrer"}},[e._v("API 文档"),a("OutboundLink")],1)]),e._v(" "),a("h2",{attrs:{id:"组件传值"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#组件传值"}},[e._v("#")]),e._v(" 组件传值")]),e._v(" "),a("ul",[a("li",[e._v("父组件通过 prop 向子组件传值")]),e._v(" "),a("li",[e._v("子组件通过事件向父组件传值")]),e._v(" "),a("li",[e._v("子组件与子组件之间不能直接传值，需要通过父组件来做间接传值，在这种情况下推荐使用 vuex")])]),e._v(" "),a("p",[e._v("具体例子请看"),a("a",{attrs:{href:"https://cn.vuejs.org/v2/guide/components.html#%E9%80%9A%E8%BF%87-Prop-%E5%90%91%E5%AD%90%E7%BB%84%E4%BB%B6%E4%BC%A0%E9%80%92%E6%95%B0%E6%8D%AE",target:"_blank",rel:"noopener noreferrer"}},[e._v("官方文档"),a("OutboundLink")],1)]),e._v(" "),a("h2",{attrs:{id:"vue-数据绑定原理"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#vue-数据绑定原理"}},[e._v("#")]),e._v(" vue 数据绑定原理")]),e._v(" "),a("p",[e._v("Vue 的数据双向绑定都是依据 Object.defineProperty() 这一方法来做的"),a("br"),e._v("\nObject.defineProperty 到底有什么作用呢？ "),a("a",{attrs:{href:"https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object/defineProperty",target:"_blank",rel:"noopener noreferrer"}},[e._v("MDN"),a("OutboundLink")],1)]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("Object.defineProperty(obj, prop, descriptor)\n\nobj\n要在其上定义属性的对象。\n\nprop\n要定义或修改的属性的名称。\n\ndescriptor\n将被定义或修改的属性描述符。\n")])])]),a("p",[e._v("简单来说 这个方法可以定义一个对象某个属性的描述符")]),e._v(" "),a("p",[e._v("我们需要用到的就是描述符当中的 getter 和 setter")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("const obj = {a:1}\nobj.a // 1\n\nobj.a = 2\n")])])]),a("p",[e._v("像上面代码中的两个操作 读取和赋值 就是在访问 obj.a 的 getter 和 setter"),a("br"),e._v("\n当我们输入 obj.a 时 就是在访问 obj 对象 a 属性的 getter 当输入 obj.a = 2 时就是在访问 obj 对象 a 属性的 setter")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("Object.defineProperty(obj, 'a', {\n  get : function(){\n    return val\n  },\n  set : function(newValue){\n    val = newValue\n  },\n  enumerable : true,\n  configurable : true\n})\n")])])]),a("p",[e._v("getter 和 setter 都是一个函数 我们还可以这样做 例如")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("get: function() {\n  // 每次访问obj.a时都会执行这段代码\n  console.log('hello, 你在读取a的值')\n  return val\n}\nset: function(newValue) {\n  val = newValue\n  // 每次给obj.a赋值时都会执行这段代码\n  console.log('你设置了a的值')\n}\n")])])]),a("p",[e._v("Vue 的双向数据绑定就是根据上面的原理来实现的 只要在读取值时收集观察者 在赋值时触发观察者更新函数 就可以实现数据变更 从而实现 DOM 重新渲染")]),e._v(" "),a("p",[e._v("说到这可能还不是很明白 不要急 慢慢来 先看一下这段代码 复制放到 HTML 文件里自己运行一下 然后打开网页 在控制台里输入 data.user.name 看看 会有惊喜")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("<!DOCTYPE html>\n<html>\n<head>\n    <meta charset=\"utf-8\">\n    <title>动态数据绑定（一）</title>\n</head>\n<body>\n <script>\n    var data = {\n        user: {\n            name: 'xiaoming',\n            age: 18,\n            occupation: 'frontend'\n        },\n        address: {\n            city: 'shaoguan'\n        }\n    }; \n    function Observer(data) {\n        this.data = data;\n        this.walk(data);\n    }\n    Observer.prototype = {\n        walk: function(obj) {\n            var value,\n                key;\n            for (key in obj) {\n                if (obj.hasOwnProperty(key)) {\n                    value = obj[key];\n                    if (typeof value === 'object') {\n                        new Observer(value);\n                    }\n                    this.convert(key, value); \n                }   \n            }\n        },\n        convert: function(key, value) {\n            Object.defineProperty(this.data, key, {\n                get : function(){ \n                    console.log(\"你访问了\" + key);\n                    return value; \n                },\n                set : function(newValue){ \n                    value = newValue; \n                    console.log('你设置了' + key + '=' + value);\n                }\n            });\n        }\n    }  \n    var example = new Observer(data);\n <\/script>   \n</body>\n</html>\n")])])]),a("h2",{attrs:{id:"vue-router-原理"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#vue-router-原理"}},[e._v("#")]),e._v(" vue-router 原理")]),e._v(" "),a("p",[e._v("说简单点，vue-router 的原理就是通过对 URL 地址变化的监听，继而对不同的组件进行渲染。"),a("br"),e._v("\n每当 URL 地址改变时，就对相应的组件进行渲染。原理是很简单，实现方式可能有点复杂，主要有 hash 模式和 history 模式。"),a("br"),e._v("\n如果想了解得详细点，建议百度或者阅读源码。")]),e._v(" "),a("h2",{attrs:{id:"vuex-原理"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#vuex-原理"}},[e._v("#")]),e._v(" vuex 原理")]),e._v(" "),a("p",[e._v("vuex 的原理其实非常简单，它为什么能实现所有的组件共享同一份数据？"),a("br"),e._v("\n因为 vuex 生成了一个 store 实例，并且把这个实例挂在了所有的组件上，所有的组件引用的都是同一个 store 实例。"),a("br"),e._v("\nstore 实例上有数据，有方法，方法改变的都是 store 实例上的数据。由于其他组件引用的是同样的实例，所以一个组件改变了 store 上的数据， 导致另一个组件上的数据也会改变，就像是一个对象的引用。"),a("br"),e._v("\n如果对 vuex 的实现有兴趣，可以看看我自己造的一个 vue 轮子对应的 "),a("a",{attrs:{href:"https://github.com/woai3c/mini-vuex/blob/master/mini-vuex.js",target:"_blank",rel:"noopener noreferrer"}},[e._v("vuex 插件"),a("OutboundLink")],1),e._v("。它实现了除 vuex 模块外的所有功能。")]),e._v(" "),a("h2",{attrs:{id:"v-if-和-v-show-的区别"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#v-if-和-v-show-的区别"}},[e._v("#")]),e._v(" v-if 和 v-show 的区别")]),e._v(" "),a("p",[a("code",[e._v("v-if")]),e._v(" 是 “真正” 的条件渲染，因为它会确保在切换过程中条件块内的事件监听器和子组件适当地被销毁和重建。")]),e._v(" "),a("p",[a("code",[e._v("v-if")]),e._v(" 也是惰性的：如果在初始渲染时条件为假，则什么也不做——直到条件第一次变为真时，才会开始渲染条件块。")]),e._v(" "),a("p",[e._v("相比之下，"),a("code",[e._v("v-show")]),e._v(" 就简单得多——不管初始条件是什么，元素总是会被渲染，并且只是简单地基于 CSS 进行切换。")]),e._v(" "),a("p",[e._v("一般来说，"),a("code",[e._v("v-if")]),e._v(" 有更高的切换开销，而 "),a("code",[e._v("v-show")]),e._v(" 有更高的初始渲染开销。因此，如果需要非常频繁地切换，则使用 "),a("code",[e._v("v-show")]),e._v(" 较好；如果在运行时条件很少改变，则使用"),a("code",[e._v("v-if")]),e._v(" 较好。")]),e._v(" "),a("p",[a("a",{attrs:{href:"https://cn.vuejs.org/v2/guide/conditional.html#v-if-vs-v-show",target:"_blank",rel:"noopener noreferrer"}},[e._v("https://cn.vuejs.org/v2/guide/conditional.html#v-if-vs-v-show"),a("OutboundLink")],1)]),e._v(" "),a("h2",{attrs:{id:"vue-怎么实现页面的权限控制"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#vue-怎么实现页面的权限控制"}},[e._v("#")]),e._v(" vue 怎么实现页面的权限控制")]),e._v(" "),a("p",[e._v("利用 "),a("code",[e._v("vue-router")]),e._v(" 的 "),a("code",[e._v("beforeEach")]),e._v(" 事件，可以在跳转页面前判断用户的权限（利用 cookie 或 token），是否能够进入此页面，如果不能则提示错误或重定向到其他页面，在后台管理系统中这种场景经常能遇到。")]),e._v(" "),a("h2",{attrs:{id:"keep-alive-有什么作用"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#keep-alive-有什么作用"}},[e._v("#")]),e._v(" keep-alive 有什么作用")]),e._v(" "),a("p",[e._v("在 "),a("code",[e._v("Vue")]),e._v(" 中，每次切换组件时，都会重新渲染。如果有多个组件切换，又想让它们保持原来的状态，避免重新渲染，这个时候就可以使用 "),a("code",[e._v("keep-alive")]),e._v("。 "),a("code",[e._v("keep-alive")]),e._v(" 可以使被包含的组件保留状态，或避免重新渲染。")]),e._v(" "),a("h2",{attrs:{id:"计算属性有什么作用"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#计算属性有什么作用"}},[e._v("#")]),e._v(" 计算属性有什么作用")]),e._v(" "),a("p",[e._v("先来看一下计算属性的定义："),a("br"),e._v("\n当其依赖的属性的值发生变化的时，计算属性会重新计算。反之则使用缓存中的属性值。"),a("br"),e._v("\n计算属性和 vue 中的其它数据一样，都是响应式的，只不过它必须依赖某一个数据实现，并且只有它依赖的数据的值改变了，它才会更新。")]),e._v(" "),a("h2",{attrs:{id:"route-和-router-的区别"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#route-和-router-的区别"}},[e._v("#")]),e._v(" $route 和 $router 的区别")]),e._v(" "),a("p",[a("code",[e._v("$route")]),e._v(" 是路由信息对象，包括"),a("code",[e._v("path")]),e._v("，"),a("code",[e._v("params")]),e._v("，"),a("code",[e._v("hash")]),e._v("，"),a("code",[e._v("query")]),e._v("，"),a("code",[e._v("fullPath")]),e._v("，"),a("code",[e._v("matched")]),e._v("，"),a("code",[e._v("name")]),e._v(" 等路由信息参数。")]),e._v(" "),a("p",[e._v("而 "),a("code",[e._v("$router")]),e._v(" 是路由实例对象，包括了路由的跳转方法，钩子函数等")]),e._v(" "),a("h2",{attrs:{id:"watch-的作用是什么"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#watch-的作用是什么"}},[e._v("#")]),e._v(" watch 的作用是什么")]),e._v(" "),a("p",[a("code",[e._v("watch")]),e._v(" 主要作用是监听某个数据值的变化。和计算属性相比除了没有缓存，作用是一样的。")]),e._v(" "),a("p",[e._v("借助 "),a("code",[e._v("watch")]),e._v(" 还可以做一些特别的事情，例如监听页面路由，当页面跳转时，我们可以做相应的权限控制，拒绝没有权限的用户访问页面。")]),e._v(" "),a("p",[e._v("写下你的评论...")]),e._v(" "),a("p",[e._v("感觉不错哦")]),e._v(" "),a("p",[e._v("谢谢")]),e._v(" "),a("p",[e._v("楼主原型继承那里写的有点问题，应该是所有的 js 对象都有___proto__属性，_"),a("em",[e._v("proto__属性指该对象构造函数的 prototype 属性")])]),e._v(" "),a("p",[a("img",{attrs:{src:"https://pic1.zhimg.com/v2-8b91ab57d3a522b4be21d834cebf97dc_r.gif",alt:""}})]),e._v(" "),a("p",[e._v("确实 已改")]),e._v(" "),a("p",[e._v("兄弟，并不是所有的对象都有__proto__属性的，创建对象有三种方式：1. 对象字面量；2. 构造函数；3.Object.create()"),a("br"),e._v("\n如果是 Object.create(null) 创建出来的对象，就没有__proto__属性，该对象也没有原型对象")]),e._v(" "),a("p",[e._v("那么到底要不要把 script 放在 body 之前啊？[捂脸][捂脸][捂脸] 是不是他问的问题就不对，故意给你挖坑")]),e._v(" "),a("p",[e._v("一般都是放在底部")]),e._v(" "),a("p",[e._v("要看执行时机，并不是都放在底部")]),e._v(" "),a("p",[e._v("img 的 src 会暂停其他资源的下载和处理吗")]),e._v(" "),a("p",[e._v("不会")]),e._v(" "),a("p",[e._v("可是你文章里是这么写的：当浏览器解析到 src ，会暂停其他资源的下载和处理，直到将该资源加载、编译、执行完毕，图片和框架等也如此")]),e._v(" "),a("p",[e._v("很全，是我见过的最详细的")]),e._v(" "),a("p",[e._v("感谢，但是大部分都不会 [捂脸]")]),e._v(" "),a("p",[e._v("这好像不只今年的吧，去年也这样问的 [捂嘴]")]),e._v(" "),a("p",[e._v("都有")]),e._v(" "),a("p",[e._v("超級全，是我見過最全的前端面試知识点")]),e._v(" "),a("p",[e._v("有没有后端的")]),e._v(" "),a("p",[e._v("没有 这个得在网上搜搜了")]),e._v(" "),a("p",[e._v("挺好的，收藏")]),e._v(" "),a("p",[e._v("厉害了")]),e._v(" "),a("p",[e._v("数组去重那个应该没有写出最优解。")]),e._v(" "),a("p",[e._v("挺好，好多问题面试都遇到了")]),e._v(" "),a("p",[e._v("有点太基础了感觉。。")]),e._v(" "),a("p",[e._v("不错~~~ 顶一个")]),e._v(" "),a("p",[e._v("可以 下载看看")]),e._v(" "),a("p",[e._v("居然看完了")]),e._v(" "),a("p",[e._v("感谢！")]),e._v(" "),a("p",[e._v("感谢！请问能不能直接跟着上面的学，然后再去找工作啊～")]),e._v(" "),a("p",[e._v("不能，这不是系统性的学习。建议你看 JS 高级程序设计第三版 然后做百度技术学院任务 2016 年的任务 做完第三阶段就能找工作了 具体请搜索引擎查一下")]),e._v(" "),a("p",[e._v("好的，感谢感谢")])])}),[],!1,null,null,null);t.default=v.exports}}]);